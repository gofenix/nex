# Nex Framework - LLM Usage Guide

You are working with **Nex**, a minimalist Elixir web framework powered by HTMX. This guide helps you understand Nex's architecture and conventions.

## Core Philosophy

- **Server-side rendering first**: No JavaScript build step required
- **HTMX-native**: Every page is an HTMX endpoint by default
- **Convention over configuration**: File-based routing, zero config
- **CDN-first**: Use Tailwind CSS, DaisyUI, and HTMX via CDN
- **Docker-ready**: Every project includes production Dockerfile

## Project Structure

```
my_app/
├── src/
│   ├── application.ex       # OTP Application (supervision tree)
│   ├── layouts.ex           # HTML layout wrapper
│   ├── pages/               # Page components (routes)
│   │   ├── index.ex         # GET /
│   │   ├── about.ex         # GET /about
│   │   └── users/
│   │       ├── [id].ex      # GET /users/:id (dynamic route)
│   │       └── [...path].ex # GET /users/* (catch-all)
│   ├── api/                 # JSON API endpoints
│   │   └── todos.ex         # GET/POST /api/todos
│   └── partials/            # Reusable components
│       └── nav.ex
├── mix.exs
└── Dockerfile
```

## Key Modules and Behaviors

### 1. `Nex.Page` - Web Pages

Pages are the primary building blocks. Each page module has two functions:

```elixir
defmodule MyApp.Pages.Index do
  use Nex

  # Called on GET request - returns initial state
  def mount(_params) do
    %{
      title: "Welcome",
      count: 0
    }
  end

  # Renders HTML using HEEx templates
  def render(assigns) do
    ~H"""
    <div>
      <h1>{@title}</h1>
      <button hx-post="/increment" hx-target="#count">+</button>
      <span id="count">{@count}</span>
    </div>
    """
  end

  # POST actions are public functions
  def increment(_params) do
    count = Nex.Store.get(:count, 0)
    Nex.Store.put(:count, count + 1)
    
    render(%{count: count + 1})
  end
end
```

**Key Points:**
- `mount/1` receives URL params and query strings
- `render/1` uses HEEx syntax (Elixir in HTML)
- POST actions automatically map to public functions
- Return HTML fragments for HTMX swaps

### 2. `Nex.Api` - JSON APIs

For REST APIs, use `Nex.Api`:

```elixir
defmodule MyApp.Api.Todos do
  use Nex

  def get(_params) do
    {:ok, %{todos: ["Buy milk", "Write code"]}}
  end

  def post(params) do
    todo = params["todo"]
    # Save todo...
    {:created, %{id: 1, todo: todo}}
  end
end
```

**Response Formats:**
- `{:ok, data}` → 200 with JSON
- `{:created, data}` → 201 with JSON
- `{:error, message}` → 400 with error JSON
- `{:not_found, message}` → 404

### 3. `Nex.SSE` - Server-Sent Events

For real-time streaming:

```elixir
defmodule MyApp.Api.Stream do
  use Nex

  def stream(conn, _params) do
    SSE.stream(conn, fn send_event ->
      send_event.("message", %{data: "Hello"})
      :timer.sleep(1000)
      :continue  # or :stop to close
    end)
  end
end
```

**Client-side (HTMX):**
```html
<div hx-ext="sse" sse-connect="/api/stream">
  <div sse-swap="message"></div>
</div>
```

### 4. `Nex.Partial` - Reusable Components

For shared UI components:

```elixir
defmodule MyApp.Partials.Nav do
  use Nex

  def render(assigns) do
    ~H"""
    <nav>
      <a href="/">Home</a>
      <a href="/about">About</a>
    </nav>
    """
  end
end

# Use in layouts or pages:
{MyApp.Partials.Nav.render(assigns)}
```

### 5. `Nex.Store` - State Management

Simple key-value store scoped to user's page session:

```elixir
# Store data
Nex.Store.put(:cart, [item1, item2])

# Retrieve data
cart = Nex.Store.get(:cart, [])

# Delete data
Nex.Store.delete(:cart)
```

**Important:** Store is per-page-session, not global. Use Phoenix.PubSub for cross-user state.

## Routing Conventions

### Static Routes
- `src/pages/index.ex` → `/`
- `src/pages/about.ex` → `/about`
- `src/pages/blog/post.ex` → `/blog/post`

### Dynamic Routes
- `src/pages/users/[id].ex` → `/users/123`
  - Access via `params["id"]`
- `src/pages/posts/[year]/[month].ex` → `/posts/2024/12`
  - Access via `params["year"]`, `params["month"]`

### Catch-All Routes
- `src/pages/docs/[...path].ex` → `/docs/guide/intro`
  - Access via `params["path"]` (list: `["guide", "intro"]`)

### API Routes
- `src/api/todos.ex` → `/api/todos`
- `src/api/users/[id].ex` → `/api/users/123`

## HTMX Integration

Nex is designed for HTMX. Common patterns:

### Form Submission
```elixir
def render(assigns) do
  ~H"""
  <form hx-post="/submit" hx-target="#result">
    {csrf_input_tag()}  <!-- Required for POST -->
    <input name="email" type="email" />
    <button type="submit">Submit</button>
  </form>
  <div id="result"></div>
  """
end

def submit(params) do
  email = params["email"]
  # Process...
  ~H"<p>Thanks, {email}!</p>"
end
```

### Partial Updates
```elixir
<button hx-post="/increment" hx-target="#counter" hx-swap="innerHTML">
  Increment
</button>
<span id="counter">{@count}</span>
```

### Boosted Navigation
All layouts should include `hx-boost="true"` on `<body>` for SPA-like navigation:
```html
<body hx-boost="true">
```

## Common Patterns

### 1. Forms with Validation
```elixir
def submit(params) do
  case validate(params) do
    {:ok, data} ->
      # Save data
      ~H"<p class='success'>Saved!</p>"
    
    {:error, errors} ->
      ~H"""
      <div class='error'>
        <p :for={err <- errors}>{err}</p>
      </div>
      """
  end
end
```

### 2. Database Integration
```elixir
# In mix.exs
{:ecto_sql, "~> 3.10"},
{:postgrex, "~> 0.17"}

# In page
def mount(_params) do
  users = MyApp.Repo.all(MyApp.User)
  %{title: "Users", users: users}
end
```

### 3. Authentication
```elixir
def mount(params) do
  case get_current_user(params) do
    nil -> redirect_to_login()
    user -> %{user: user, title: "Dashboard"}
  end
end
```

### 4. Broadcasting with PubSub
```elixir
# In Application.ex
{Phoenix.PubSub, name: MyApp.PubSub}

# Broadcast
Phoenix.PubSub.broadcast(MyApp.PubSub, "updates", {:new_message, msg})

# Subscribe (in SSE)
Phoenix.PubSub.subscribe(MyApp.PubSub, "updates")
```

## Development Commands

```bash
# Create new project
mix archive.install hex nex_new
mix nex.new my_app
cd my_app

# Development (with hot reload)
mix nex.dev

# Production
mix nex.start

# Docker
docker build -t my_app .
docker run -p 4000:4000 my_app
```

## Environment Variables

Create `.env` file:
```bash
PORT=4000
HOST=localhost
DATABASE_URL=postgres://...
SECRET_KEY=...
```

Access in code:
```elixir
System.get_env("DATABASE_URL")
```

## Security

### CSRF Protection
Always include in forms:
```elixir
{csrf_input_tag()}
```

For HTMX requests, add to layout `<head>`:
```html
<meta name="csrf-token" content={Nex.CSRF.generate_token()} />
<script>
  document.body.addEventListener('htmx:configRequest', (e) => {
    e.detail.headers['X-CSRF-Token'] = 
      document.querySelector('meta[name="csrf-token"]').content;
  });
</script>
```

## Performance Tips

1. **SSE Connections**: Can handle 1,000-10,000 concurrent connections per server
2. **State Management**: Use `Nex.Store` for per-user state, PubSub for global
3. **Database**: Use Ecto connection pooling (default 10 connections)
4. **Caching**: Use ETS for in-memory caching

## Common Mistakes to Avoid

❌ **Don't** use `String.to_atom/1` with user input (security risk)
✅ **Do** use `String.to_existing_atom/1` or pattern matching

❌ **Don't** forget `csrf_input_tag()` in forms
✅ **Do** include CSRF token in all POST forms

❌ **Don't** use global state in modules (not process-safe)
✅ **Do** use `Nex.Store`, ETS, or GenServer for state

❌ **Don't** return full HTML pages from POST actions
✅ **Do** return HTML fragments for HTMX to swap

## When to Use What

- **`Nex.Page`**: Web pages, forms, dashboards (most common)
- **`Nex.Api`**: REST APIs for mobile apps or SPAs
- **`Nex.SSE`**: Real-time updates, live data, streaming
- **`Nex.Partial`**: Reusable UI components (nav, footer, cards)

## Examples

Check out real examples:
- Counter: Basic HTMX interactions
- Todos: CRUD with state management
- Guestbook: Forms and validation
- Chatbot: AI streaming with SSE
- Dynamic Routes: URL parameters

## Further Reading

- [Official Docs](https://github.com/gofenix/nex)
- [HTMX Documentation](https://htmx.org)
- [HEEx Templates](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html)
- [Elixir Guides](https://elixir-lang.org/getting-started/introduction.html)
