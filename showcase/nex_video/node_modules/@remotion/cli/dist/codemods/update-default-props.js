"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDefaultProps = void 0;
const stringify_with_path_1 = require("./stringify-with-path");
const findStarter = ({ input, compositionId, }) => {
    const format1 = input.indexOf(`id="${compositionId}"`);
    if (format1 > -1) {
        return format1;
    }
    const format2 = input.indexOf(`id='${compositionId}'`);
    if (format2 > -1) {
        return format2;
    }
    const format3 = input.indexOf(`id={'${compositionId}'}`);
    if (format3 > -1) {
        return format3;
    }
    const format4 = input.indexOf(`id={"${compositionId}"}`);
    if (format4 > -1) {
        return format4;
    }
    const format5 = input.indexOf(`id={\`${compositionId}\``);
    if (format5 > -1) {
        return format5;
    }
    throw new Error(`Could not find composition ID ${compositionId} in file`);
};
const findEndPosition = (input, currentPosition) => {
    const asConstVersion = input
        .slice(currentPosition + 1)
        .search(/as\sconst[ \t\n\r]+\}/);
    if (asConstVersion !== -1) {
        const nextEnd = input.indexOf('}', asConstVersion + currentPosition + 1);
        return nextEnd - 1;
    }
    const next = input.indexOf('}}', currentPosition + 1);
    if (next !== -1) {
        return next;
    }
    throw new Error('Could not find end of defaultProps');
};
const findEnder = (input, position, maxPosition, compositionId) => {
    let currentPosition = position;
    while (currentPosition < maxPosition) {
        const next = findEndPosition(input, currentPosition);
        currentPosition = next;
        const nextChar = input[next + 1];
        if (nextChar === ',') {
            continue;
        }
        return [position, currentPosition + 1];
    }
    throw new Error(`No \`defaultProps\` prop found in the <Composition/> tag with the ID "${compositionId}".`);
};
const findTerminators = (input, position) => {
    const nextComposition = input.indexOf('<Composition', position);
    if (nextComposition > -1) {
        return nextComposition;
    }
    const nextStill = input.indexOf('<Still', position);
    if (nextStill > -1) {
        return nextStill;
    }
    return Infinity;
};
const updateDefaultProps = async ({ input, compositionId, newDefaultProps, enumPaths, }) => {
    const starter = findStarter({ input, compositionId });
    const START_TOKEN = 'defaultProps={';
    const start = input.indexOf(START_TOKEN, starter);
    if (start === -1) {
        throw new Error(`No \`defaultProps\` prop found in the <Composition/> tag with the ID "${compositionId}".`);
    }
    const maxEnd = findTerminators(input, starter);
    const [startPos, endPos] = findEnder(input, start + START_TOKEN.length, maxEnd, compositionId);
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    let prettier = null;
    try {
        prettier = await Promise.resolve().then(() => __importStar(require('prettier')));
    }
    catch (err) {
        throw new Error('Prettier cannot be found in the current project.');
    }
    const { format, resolveConfig, resolveConfigFile } = prettier;
    const newFile = input.substring(0, startPos) +
        (0, stringify_with_path_1.stringifyDefaultProps)({ props: newDefaultProps, enumPaths }) +
        input.substring(endPos);
    const configFilePath = await resolveConfigFile();
    if (!configFilePath) {
        throw new Error('The Prettier config file was not found');
    }
    const prettierConfig = await resolveConfig(configFilePath);
    if (!prettierConfig) {
        throw new Error(`The Prettier config at ${configFilePath} could not be read`);
    }
    const prettified = format(newFile, {
        ...prettierConfig,
        rangeStart: startPos,
        rangeEnd: endPos,
        filepath: 'test.tsx',
        plugins: [],
        endOfLine: 'auto',
    });
    return prettified;
};
exports.updateDefaultProps = updateDefaultProps;
