"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorLoading = exports.CanvasOrLoading = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const remotion_1 = require("remotion");
const ErrorLoader_1 = require("../../preview-server/error-overlay/remotion-overlay/ErrorLoader");
const colors_1 = require("../helpers/colors");
const Canvas_1 = require("./Canvas");
const layout_1 = require("./layout");
const styles_1 = require("./Menu/styles");
const Spinner_1 = require("./Spinner");
const FramePersistor_1 = require("./FramePersistor");
const ZoomPersistor_1 = require("./ZoomPersistor");
const timeline_scroll_logic_1 = require("./Timeline/timeline-scroll-logic");
const timeline_zoom_1 = require("../state/timeline-zoom");
const imperative_state_1 = require("./Timeline/imperative-state");
const container = {
    color: 'white',
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    display: 'flex',
    backgroundColor: colors_1.BACKGROUND,
    flexDirection: 'column',
};
const CanvasOrLoading = () => {
    const resolved = remotion_1.Internals.useResolvedVideoConfig(null);
    const [takesALongTime, setTakesALongTime] = (0, react_1.useState)(false);
    const { setZoom } = (0, react_1.useContext)(timeline_zoom_1.TimelineZoomCtx);
    (0, react_1.useEffect)(() => {
        const timeout = setTimeout(() => {
            setTakesALongTime(true);
        }, 500);
        return () => {
            clearTimeout(timeout);
        };
    }, []);
    (0, react_1.useEffect)(() => {
        if ((resolved === null || resolved === void 0 ? void 0 : resolved.type) !== 'success') {
            return;
        }
        const c = resolved.result;
        setTimeout(() => {
            (0, timeline_scroll_logic_1.ensureFrameIsInViewport)({
                direction: 'center',
                frame: (0, imperative_state_1.getCurrentFrame)(),
                durationInFrames: c.durationInFrames,
            });
        });
    }, [resolved, setZoom]);
    const style = (0, react_1.useMemo)(() => {
        return {
            ...loaderLabel,
            opacity: takesALongTime ? 1 : 0,
            transition: 'opacity 0.3s',
        };
    }, [takesALongTime]);
    if (!resolved) {
        return null;
    }
    if (resolved.type === 'loading') {
        return ((0, jsx_runtime_1.jsxs)("div", { style: container, className: "css-reset", children: [(0, jsx_runtime_1.jsx)(Spinner_1.Spinner, { size: 30, duration: 1 }), (0, jsx_runtime_1.jsx)(layout_1.Spacing, { y: 2 }), (0, jsx_runtime_1.jsxs)("div", { style: style, children: ["Running ", (0, jsx_runtime_1.jsx)("code", { style: styles_1.inlineCodeSnippet, children: "calculateMetadata()" }), "..."] })] }));
    }
    if (resolved.type === 'error') {
        return (0, jsx_runtime_1.jsx)(exports.ErrorLoading, { error: resolved.error });
    }
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(FramePersistor_1.FramePersistor, {}), (0, jsx_runtime_1.jsx)(ZoomPersistor_1.ZoomPersistor, {}), (0, jsx_runtime_1.jsx)(Canvas_1.Canvas, {})] }));
};
exports.CanvasOrLoading = CanvasOrLoading;
const loaderLabel = {
    fontSize: 14,
    color: colors_1.LIGHT_TEXT,
    fontFamily: 'sans-serif',
    lineHeight: 1.5,
};
const loaderContainer = {
    marginLeft: 'auto',
    marginRight: 'auto',
    width: '100%',
    position: 'absolute',
    height: '100%',
    overflowY: 'auto',
};
const ErrorLoading = ({ error }) => {
    return ((0, jsx_runtime_1.jsx)("div", { style: loaderContainer, children: (0, jsx_runtime_1.jsx)(ErrorLoader_1.ErrorLoader, { canHaveDismissButton: false, keyboardShortcuts: false, error: error, onRetry: () => { var _a; return (_a = remotion_1.Internals.resolveCompositionsRef.current) === null || _a === void 0 ? void 0 : _a.reloadCurrentlySelectedComposition(); }, calculateMetadata: true }, error.stack) }));
};
exports.ErrorLoading = ErrorLoading;
