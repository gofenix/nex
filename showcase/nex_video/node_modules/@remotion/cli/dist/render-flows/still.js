"use strict";
// Prints to CLI and also reports back to browser
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderStillFlow = void 0;
const renderer_1 = require("@remotion/renderer");
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const chalk_1 = require("../chalk");
const cleanup_before_quit_1 = require("../cleanup-before-quit");
const config_1 = require("../config");
const determine_image_format_1 = require("../determine-image-format");
const get_cli_options_1 = require("../get-cli-options");
const get_composition_with_dimension_override_1 = require("../get-composition-with-dimension-override");
const log_1 = require("../log");
const parse_command_line_1 = require("../parse-command-line");
const progress_bar_1 = require("../progress-bar");
const progress_types_1 = require("../progress-types");
const setup_cache_1 = require("../setup-cache");
const should_use_non_overlaying_logger_1 = require("../should-use-non-overlaying-logger");
const truthy_1 = require("../truthy");
const user_passed_output_location_1 = require("../user-passed-output-location");
const renderStillFlow = async ({ remotionRoot, fullEntryPoint, entryPointReason, remainingArgs, browser, browserExecutable, chromiumOptions, envVariables, height, inputProps, overwrite, port, publicDir, puppeteerTimeout, jpegQuality, scale, stillFrame, width, compositionIdFromUi, imageFormatFromUi, logLevel, onProgress, indentOutput, addCleanupCallback, cancelSignal, outputLocationFromUi, }) => {
    var _a, _b;
    const downloads = [];
    const aggregate = (0, progress_types_1.initialAggregateRenderProgress)();
    const updatesDontOverwrite = (0, should_use_non_overlaying_logger_1.shouldUseNonOverlayingLogger)({ logLevel });
    let renderProgress = null;
    const steps = [
        renderer_1.RenderInternals.isServeUrl(fullEntryPoint) ? null : 'bundling',
        'rendering',
    ].filter(truthy_1.truthy);
    const updateProgress = (newline) => {
        const { output, progress, message } = (0, progress_bar_1.makeRenderingAndStitchingProgress)({
            prog: aggregate,
            steps: steps.length,
            stitchingStep: steps.indexOf('stitching'),
        });
        if (renderProgress) {
            renderProgress.update(updatesDontOverwrite ? message : output, newline);
        }
        onProgress({ message, value: progress, ...aggregate });
    };
    if (browserExecutable) {
        log_1.Log.verboseAdvanced({ indent: indentOutput, logLevel }, 'Browser executable: ', browserExecutable);
    }
    const browserInstance = renderer_1.RenderInternals.internalOpenBrowser({
        browser,
        browserExecutable,
        chromiumOptions,
        forceDeviceScaleFactor: scale,
        indent: indentOutput,
        viewport: null,
        logLevel,
    });
    const { cleanup: cleanupBundle, urlOrBundle } = await (0, setup_cache_1.bundleOnCliOrTakeServeUrl)({
        fullPath: fullEntryPoint,
        remotionRoot,
        steps: steps.length,
        publicDir,
        onProgress: ({ copying, bundling }) => {
            aggregate.bundling = bundling;
            aggregate.copyingState = copying;
            updateProgress(false);
        },
        indentOutput,
        logLevel,
        bundlingStep: steps.indexOf('bundling'),
        onDirectoryCreated: (dir) => {
            (0, cleanup_before_quit_1.registerCleanupJob)(() => {
                renderer_1.RenderInternals.deleteDirectory(dir);
            });
        },
        quietProgress: updatesDontOverwrite,
    });
    const server = renderer_1.RenderInternals.prepareServer({
        concurrency: 1,
        indent: indentOutput,
        port,
        remotionRoot,
        logLevel,
        webpackConfigOrServeUrl: urlOrBundle,
    });
    addCleanupCallback(() => server.then((s) => s.closeServer(false)));
    addCleanupCallback(() => cleanupBundle());
    const puppeteerInstance = await browserInstance;
    addCleanupCallback(() => puppeteerInstance.close(false, logLevel, indentOutput));
    const { compositionId, config, reason, argsAfterComposition } = await (0, get_composition_with_dimension_override_1.getCompositionWithDimensionOverride)({
        height,
        width,
        args: remainingArgs,
        compositionIdFromUi,
        browserExecutable,
        chromiumOptions,
        envVariables,
        indent: indentOutput,
        inputProps,
        port,
        puppeteerInstance,
        serveUrlOrWebpackUrl: urlOrBundle,
        timeoutInMilliseconds: puppeteerTimeout,
        logLevel,
        server: await server,
    });
    const { format: imageFormat, source } = (0, determine_image_format_1.determineFinalStillImageFormat)({
        cliFlag: (_a = parse_command_line_1.parsedCli['image-format']) !== null && _a !== void 0 ? _a : null,
        configImageFormat: (_b = config_1.ConfigInternals.getUserPreferredStillImageFormat()) !== null && _b !== void 0 ? _b : null,
        downloadName: null,
        outName: (0, user_passed_output_location_1.getUserPassedOutputLocation)(argsAfterComposition, outputLocationFromUi),
        isLambda: false,
        fromUi: imageFormatFromUi,
    });
    const relativeOutputLocation = (0, user_passed_output_location_1.getOutputLocation)({
        compositionId,
        defaultExtension: imageFormat,
        args: argsAfterComposition,
        type: 'asset',
        outputLocationFromUi,
    });
    const absoluteOutputLocation = (0, get_cli_options_1.getAndValidateAbsoluteOutputFile)(relativeOutputLocation, overwrite);
    const exists = (0, node_fs_1.existsSync)(absoluteOutputLocation);
    (0, node_fs_1.mkdirSync)(node_path_1.default.join(absoluteOutputLocation, '..'), {
        recursive: true,
    });
    log_1.Log.verboseAdvanced({ indent: indentOutput, logLevel }, chalk_1.chalk.gray(`Entry point = ${fullEntryPoint} (${entryPointReason})`));
    log_1.Log.infoAdvanced({ indent: indentOutput, logLevel }, chalk_1.chalk.gray(`Composition = ${compositionId} (${reason}), Format = ${imageFormat} (${source}), Output = ${relativeOutputLocation}`));
    renderProgress = (0, progress_bar_1.createOverwriteableCliOutput)({
        quiet: (0, parse_command_line_1.quietFlagProvided)(),
        cancelSignal,
        updatesDontOverwrite: (0, should_use_non_overlaying_logger_1.shouldUseNonOverlayingLogger)({ logLevel }),
        indent: indentOutput,
    });
    const renderStart = Date.now();
    aggregate.rendering = {
        frames: 0,
        concurrency: 1,
        doneIn: null,
        steps,
        totalFrames: 1,
    };
    updateProgress(false);
    const onDownload = (src) => {
        const id = Math.random();
        const download = {
            id,
            name: src,
            progress: 0,
            downloaded: 0,
            totalBytes: null,
        };
        downloads.push(download);
        updateProgress(false);
        return ({ percent }) => {
            download.progress = percent;
            updateProgress(false);
        };
    };
    await renderer_1.RenderInternals.internalRenderStill({
        composition: config,
        frame: stillFrame,
        output: absoluteOutputLocation,
        serveUrl: urlOrBundle,
        jpegQuality,
        envVariables,
        imageFormat,
        inputProps,
        chromiumOptions,
        timeoutInMilliseconds: puppeteerTimeout,
        scale,
        browserExecutable,
        overwrite,
        onDownload,
        port,
        puppeteerInstance,
        server: await server,
        cancelSignal,
        indent: indentOutput,
        onBrowserLog: null,
        logLevel,
    });
    aggregate.rendering = {
        frames: 1,
        concurrency: 1,
        doneIn: Date.now() - renderStart,
        steps,
        totalFrames: 1,
    };
    updateProgress(true);
    log_1.Log.infoAdvanced({ indent: indentOutput, logLevel }, chalk_1.chalk.blue(`${exists ? 'â—‹' : '+'} ${absoluteOutputLocation}`));
};
exports.renderStillFlow = renderStillFlow;
