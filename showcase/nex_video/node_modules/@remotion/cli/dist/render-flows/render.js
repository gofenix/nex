"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderVideoFlow = void 0;
const renderer_1 = require("@remotion/renderer");
const node_fs_1 = __importStar(require("node:fs"));
const node_os_1 = __importDefault(require("node:os"));
const node_path_1 = __importDefault(require("node:path"));
const chalk_1 = require("../chalk");
const config_1 = require("../config");
const get_cli_options_1 = require("../get-cli-options");
const get_composition_with_dimension_override_1 = require("../get-composition-with-dimension-override");
const get_filename_1 = require("../get-filename");
const get_final_output_codec_1 = require("../get-final-output-codec");
const image_formats_1 = require("../image-formats");
const log_1 = require("../log");
const parse_command_line_1 = require("../parse-command-line");
const progress_bar_1 = require("../progress-bar");
const setup_cache_1 = require("../setup-cache");
const should_use_non_overlaying_logger_1 = require("../should-use-non-overlaying-logger");
const truthy_1 = require("../truthy");
const user_passed_output_location_1 = require("../user-passed-output-location");
const renderVideoFlow = async ({ remotionRoot, fullEntryPoint, indent, logLevel, browserExecutable, browser, chromiumOptions, scale, shouldOutputImageSequence, publicDir, inputProps, envVariables, puppeteerTimeout, port, height, width, remainingArgs, compositionIdFromUi, entryPointReason, overwrite, quiet, concurrency, frameRange, everyNthFrame, outputLocationFromUI, jpegQuality, onProgress, addCleanupCallback, cancelSignal, crf, uiCodec, uiImageFormat, ffmpegOverride, audioBitrate, muted, enforceAudioTrack, proResProfile, pixelFormat, videoBitrate, numberOfGifLoops, audioCodec, disallowParallelEncoding, }) => {
    var _a;
    const downloads = [];
    if (browserExecutable) {
        log_1.Log.verboseAdvanced({ indent, logLevel }, 'Browser executable: ', browserExecutable);
    }
    const browserInstance = renderer_1.RenderInternals.internalOpenBrowser({
        browser,
        browserExecutable,
        chromiumOptions,
        forceDeviceScaleFactor: scale,
        indent,
        viewport: null,
        logLevel,
    });
    const updatesDontOverwrite = (0, should_use_non_overlaying_logger_1.shouldUseNonOverlayingLogger)({ logLevel });
    const renderProgress = (0, progress_bar_1.createOverwriteableCliOutput)({
        quiet,
        cancelSignal,
        updatesDontOverwrite,
        indent,
    });
    const steps = [
        renderer_1.RenderInternals.isServeUrl(fullEntryPoint) ? null : 'bundling',
        'rendering',
        shouldOutputImageSequence ? null : 'stitching',
    ].filter(truthy_1.truthy);
    let bundlingProgress = {
        doneIn: null,
        progress: 0,
    };
    let renderingProgress = null;
    let stitchingProgress = null;
    let copyingState = {
        bytes: 0,
        doneIn: null,
    };
    const updateRenderProgress = (newline) => {
        const aggregateRenderProgress = {
            rendering: renderingProgress,
            stitching: shouldOutputImageSequence ? null : stitchingProgress,
            downloads,
            bundling: bundlingProgress,
            copyingState,
        };
        const { output, message, progress } = (0, progress_bar_1.makeRenderingAndStitchingProgress)({
            prog: aggregateRenderProgress,
            steps: steps.length,
            stitchingStep: steps.indexOf('stitching'),
        });
        onProgress({ message, value: progress, ...aggregateRenderProgress });
        return renderProgress.update(updatesDontOverwrite ? message : output, newline);
    };
    const { urlOrBundle, cleanup: cleanupBundle } = await (0, setup_cache_1.bundleOnCliOrTakeServeUrl)({
        fullPath: fullEntryPoint,
        remotionRoot,
        publicDir,
        onProgress: ({ bundling, copying }) => {
            bundlingProgress = bundling;
            copyingState = copying;
            updateRenderProgress(false);
        },
        indentOutput: indent,
        logLevel,
        bundlingStep: steps.indexOf('bundling'),
        steps: steps.length,
        onDirectoryCreated: (dir) => {
            addCleanupCallback(() => renderer_1.RenderInternals.deleteDirectory(dir));
        },
        quietProgress: updatesDontOverwrite,
    });
    addCleanupCallback(() => cleanupBundle());
    const onDownload = (src) => {
        const id = Math.random();
        const download = {
            id,
            name: src,
            progress: 0,
            downloaded: 0,
            totalBytes: null,
        };
        downloads.push(download);
        updateRenderProgress(false);
        return ({ percent, downloaded, totalSize }) => {
            download.progress = percent;
            download.totalBytes = totalSize;
            download.downloaded = downloaded;
            updateRenderProgress(false);
        };
    };
    const puppeteerInstance = await browserInstance;
    addCleanupCallback(() => puppeteerInstance.close(false, logLevel, indent));
    const actualConcurrency = renderer_1.RenderInternals.getActualConcurrency(concurrency);
    const server = renderer_1.RenderInternals.prepareServer({
        concurrency: actualConcurrency,
        indent,
        port,
        remotionRoot,
        logLevel,
        webpackConfigOrServeUrl: urlOrBundle,
    });
    addCleanupCallback(() => server.then((s) => s.closeServer(false)));
    const { compositionId, config, reason, argsAfterComposition } = await (0, get_composition_with_dimension_override_1.getCompositionWithDimensionOverride)({
        height,
        width,
        args: remainingArgs,
        compositionIdFromUi,
        browserExecutable,
        chromiumOptions,
        envVariables,
        indent,
        inputProps,
        port,
        puppeteerInstance,
        serveUrlOrWebpackUrl: urlOrBundle,
        timeoutInMilliseconds: puppeteerTimeout,
        logLevel,
        server: await server,
    });
    const { codec, reason: codecReason } = (0, get_final_output_codec_1.getFinalOutputCodec)({
        cliFlag: parse_command_line_1.parsedCli.codec,
        configFile: (_a = config_1.ConfigInternals.getOutputCodecOrUndefined()) !== null && _a !== void 0 ? _a : null,
        downloadName: null,
        outName: (0, user_passed_output_location_1.getUserPassedOutputLocation)(argsAfterComposition, outputLocationFromUI),
        uiCodec,
    });
    renderer_1.RenderInternals.validateEvenDimensionsWithCodec({
        width: config.width,
        height: config.height,
        codec,
        scale,
    });
    const relativeOutputLocation = (0, get_filename_1.getOutputFilename)({
        imageSequence: shouldOutputImageSequence,
        compositionName: compositionId,
        defaultExtension: renderer_1.RenderInternals.getFileExtensionFromCodec(codec, audioCodec),
        args: argsAfterComposition,
        indent,
        fromUi: outputLocationFromUI,
        logLevel,
    });
    log_1.Log.verboseAdvanced({ indent, logLevel }, chalk_1.chalk.gray(`Entry point = ${fullEntryPoint} (${entryPointReason})`));
    log_1.Log.infoAdvanced({ indent, logLevel }, chalk_1.chalk.gray(`Composition = ${compositionId} (${reason}), Codec = ${codec} (${codecReason}), Output = ${relativeOutputLocation}`));
    const absoluteOutputFile = (0, get_cli_options_1.getAndValidateAbsoluteOutputFile)(relativeOutputLocation, overwrite);
    const exists = (0, node_fs_1.existsSync)(absoluteOutputFile);
    const realFrameRange = renderer_1.RenderInternals.getRealFrameRange(config.durationInFrames, frameRange);
    const totalFrames = renderer_1.RenderInternals.getFramesToRender(realFrameRange, everyNthFrame);
    renderingProgress = {
        frames: 0,
        totalFrames: totalFrames.length,
        concurrency: actualConcurrency,
        doneIn: null,
        steps,
    };
    const imageFormat = (0, image_formats_1.getVideoImageFormat)({
        codec: shouldOutputImageSequence ? undefined : codec,
        uiImageFormat,
    });
    if (shouldOutputImageSequence) {
        node_fs_1.default.mkdirSync(absoluteOutputFile, {
            recursive: true,
        });
        if (imageFormat === 'none') {
            throw new Error(`Cannot render an image sequence with a codec that renders no images. codec = ${codec}, imageFormat = ${imageFormat}`);
        }
        const outputDir = shouldOutputImageSequence
            ? absoluteOutputFile
            : await node_fs_1.default.promises.mkdtemp(node_path_1.default.join(node_os_1.default.tmpdir(), 'react-motion-render'));
        log_1.Log.verboseAdvanced({ indent, logLevel }, 'Output dir', outputDir);
        await renderer_1.RenderInternals.internalRenderFrames({
            imageFormat,
            inputProps,
            onFrameUpdate: (rendered) => {
                renderingProgress.frames = rendered;
                updateRenderProgress(false);
            },
            onStart: () => undefined,
            onDownload,
            cancelSignal: cancelSignal !== null && cancelSignal !== void 0 ? cancelSignal : undefined,
            outputDir,
            webpackBundleOrServeUrl: urlOrBundle,
            everyNthFrame,
            envVariables,
            frameRange,
            concurrency: actualConcurrency,
            puppeteerInstance,
            jpegQuality: jpegQuality !== null && jpegQuality !== void 0 ? jpegQuality : renderer_1.RenderInternals.DEFAULT_JPEG_QUALITY,
            timeoutInMilliseconds: puppeteerTimeout,
            chromiumOptions,
            scale,
            browserExecutable,
            port,
            composition: config,
            server: await server,
            indent,
            muted,
            onBrowserLog: null,
            onFrameBuffer: null,
            logLevel,
        });
        updateRenderProgress(true);
        log_1.Log.infoAdvanced({ indent, logLevel }, chalk_1.chalk.blue(`▶ ${absoluteOutputFile}`));
        return;
    }
    stitchingProgress = {
        doneIn: null,
        frames: 0,
        stage: 'encoding',
        totalFrames: totalFrames.length,
        codec,
    };
    const { slowestFrames } = await renderer_1.RenderInternals.internalRenderMedia({
        outputLocation: absoluteOutputFile,
        composition: {
            ...config,
            width: width !== null && width !== void 0 ? width : config.width,
            height: height !== null && height !== void 0 ? height : config.height,
        },
        crf: crf !== null && crf !== void 0 ? crf : null,
        envVariables,
        frameRange,
        inputProps,
        overwrite,
        pixelFormat,
        proResProfile,
        jpegQuality: jpegQuality !== null && jpegQuality !== void 0 ? jpegQuality : renderer_1.RenderInternals.DEFAULT_JPEG_QUALITY,
        chromiumOptions,
        timeoutInMilliseconds: config_1.ConfigInternals.getCurrentPuppeteerTimeout(),
        scale,
        port,
        numberOfGifLoops,
        everyNthFrame,
        logLevel,
        muted,
        enforceAudioTrack,
        browserExecutable,
        ffmpegOverride,
        concurrency,
        serveUrl: urlOrBundle,
        codec,
        audioBitrate,
        videoBitrate,
        onProgress: (update) => {
            stitchingProgress.doneIn =
                update.encodedDoneIn;
            stitchingProgress.frames =
                update.encodedFrames;
            stitchingProgress.stage = update.stitchStage;
            renderingProgress.doneIn =
                update.renderedDoneIn;
            renderingProgress.frames =
                update.renderedFrames;
            updateRenderProgress(false);
        },
        puppeteerInstance,
        onDownload,
        onCtrlCExit: addCleanupCallback,
        indent,
        server: await server,
        cancelSignal: cancelSignal !== null && cancelSignal !== void 0 ? cancelSignal : undefined,
        audioCodec,
        preferLossless: false,
        imageFormat,
        disallowParallelEncoding,
        onBrowserLog: null,
        onStart: () => undefined,
    });
    updateRenderProgress(true);
    log_1.Log.infoAdvanced({ indent, logLevel }, chalk_1.chalk.blue(`${exists ? '○' : '+'} ${absoluteOutputFile}`));
    log_1.Log.verboseAdvanced({ indent, logLevel }, `Slowest frames:`);
    slowestFrames.forEach(({ frame, time }) => {
        log_1.Log.verboseAdvanced({ indent, logLevel }, `  Frame ${frame} (${time.toFixed(3)}ms)`);
    });
    for (const line of renderer_1.RenderInternals.perf.getPerf()) {
        log_1.Log.verboseAdvanced({ indent, logLevel }, line);
    }
};
exports.renderVideoFlow = renderVideoFlow;
