"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Player = exports.componentOrNullIfLazy = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const remotion_1 = require("remotion");
const emitter_context_js_1 = require("./emitter-context.js");
const event_emitter_js_1 = require("./event-emitter.js");
const player_css_classname_js_1 = require("./player-css-classname.js");
const PlayerUI_js_1 = __importDefault(require("./PlayerUI.js"));
const SharedPlayerContext_js_1 = require("./SharedPlayerContext.js");
const validate_in_out_frame_js_1 = require("./utils/validate-in-out-frame.js");
const validate_initial_frame_js_1 = require("./utils/validate-initial-frame.js");
const validate_playbackrate_js_1 = require("./utils/validate-playbackrate.js");
const componentOrNullIfLazy = (props) => {
    if ('component' in props) {
        return props.component;
    }
    return null;
};
exports.componentOrNullIfLazy = componentOrNullIfLazy;
const PlayerFn = ({ durationInFrames, compositionHeight, compositionWidth, fps, inputProps, style, controls = false, loop = false, autoPlay = false, showVolumeControls = true, allowFullscreen = true, clickToPlay, doubleClickToFullscreen = false, spaceKeyToPlayOrPause = true, moveToBeginningWhenEnded = true, numberOfSharedAudioTags = 5, errorFallback = () => '⚠️', playbackRate = 1, renderLoading, className, showPosterWhenUnplayed, showPosterWhenEnded, showPosterWhenPaused, initialFrame, renderPoster, inFrame, outFrame, initiallyShowControls, renderFullscreenButton, renderPlayPauseButton, alwaysShowControls = false, initiallyMuted = false, showPlaybackRateControl = false, ...componentProps }, ref) => {
    if (typeof window !== 'undefined') {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, react_1.useLayoutEffect)(() => {
            window.remotion_isPlayer = true;
        }, []);
    }
    // @ts-expect-error
    if (componentProps.defaultProps !== undefined) {
        throw new Error('The <Player /> component does not accept `defaultProps`, but some were passed. Use `inputProps` instead.');
    }
    const componentForValidation = (0, exports.componentOrNullIfLazy)(componentProps);
    // @ts-expect-error
    if ((componentForValidation === null || componentForValidation === void 0 ? void 0 : componentForValidation.type) === remotion_1.Composition) {
        throw new TypeError(`'component' should not be an instance of <Composition/>. Pass the React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.`);
    }
    if (componentForValidation === remotion_1.Composition) {
        throw new TypeError(`'component' must not be the 'Composition' component. Pass your own React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.`);
    }
    const component = remotion_1.Internals.useLazyComponent(componentProps);
    (0, validate_initial_frame_js_1.validateInitialFrame)({ initialFrame, durationInFrames });
    const [frame, setFrame] = (0, react_1.useState)(() => ({
        [SharedPlayerContext_js_1.PLAYER_COMP_ID]: initialFrame !== null && initialFrame !== void 0 ? initialFrame : 0,
    }));
    const [playing, setPlaying] = (0, react_1.useState)(false);
    const [rootId] = (0, react_1.useState)('player-comp');
    const [emitter] = (0, react_1.useState)(() => new event_emitter_js_1.PlayerEmitter());
    const rootRef = (0, react_1.useRef)(null);
    const audioAndVideoTags = (0, react_1.useRef)([]);
    const imperativePlaying = (0, react_1.useRef)(false);
    const [currentPlaybackRate, setCurrentPlaybackRate] = (0, react_1.useState)(playbackRate);
    if (typeof compositionHeight !== 'number') {
        throw new TypeError(`'compositionHeight' must be a number but got '${typeof compositionHeight}' instead`);
    }
    if (typeof compositionWidth !== 'number') {
        throw new TypeError(`'compositionWidth' must be a number but got '${typeof compositionWidth}' instead`);
    }
    remotion_1.Internals.validateDimension(compositionHeight, 'compositionHeight', 'of the <Player /> component');
    remotion_1.Internals.validateDimension(compositionWidth, 'compositionWidth', 'of the <Player /> component');
    remotion_1.Internals.validateDurationInFrames(durationInFrames, {
        component: 'of the <Player/> component',
        allowFloats: false,
    });
    remotion_1.Internals.validateFps(fps, 'as a prop of the <Player/> component', false);
    remotion_1.Internals.validateDefaultAndInputProps(inputProps, 'inputProps', null);
    (0, validate_in_out_frame_js_1.validateInOutFrames)({
        durationInFrames,
        inFrame,
        outFrame,
    });
    if (typeof controls !== 'boolean' && typeof controls !== 'undefined') {
        throw new TypeError(`'controls' must be a boolean or undefined but got '${typeof controls}' instead`);
    }
    if (typeof autoPlay !== 'boolean' && typeof autoPlay !== 'undefined') {
        throw new TypeError(`'autoPlay' must be a boolean or undefined but got '${typeof autoPlay}' instead`);
    }
    if (typeof loop !== 'boolean' && typeof loop !== 'undefined') {
        throw new TypeError(`'loop' must be a boolean or undefined but got '${typeof loop}' instead`);
    }
    if (typeof doubleClickToFullscreen !== 'boolean' &&
        typeof doubleClickToFullscreen !== 'undefined') {
        throw new TypeError(`'doubleClickToFullscreen' must be a boolean or undefined but got '${typeof doubleClickToFullscreen}' instead`);
    }
    if (typeof showVolumeControls !== 'boolean' &&
        typeof showVolumeControls !== 'undefined') {
        throw new TypeError(`'showVolumeControls' must be a boolean or undefined but got '${typeof showVolumeControls}' instead`);
    }
    if (typeof allowFullscreen !== 'boolean' &&
        typeof allowFullscreen !== 'undefined') {
        throw new TypeError(`'allowFullscreen' must be a boolean or undefined but got '${typeof allowFullscreen}' instead`);
    }
    if (typeof clickToPlay !== 'boolean' && typeof clickToPlay !== 'undefined') {
        throw new TypeError(`'clickToPlay' must be a boolean or undefined but got '${typeof clickToPlay}' instead`);
    }
    if (typeof spaceKeyToPlayOrPause !== 'boolean' &&
        typeof spaceKeyToPlayOrPause !== 'undefined') {
        throw new TypeError(`'spaceKeyToPlayOrPause' must be a boolean or undefined but got '${typeof spaceKeyToPlayOrPause}' instead`);
    }
    if (typeof numberOfSharedAudioTags !== 'number' ||
        numberOfSharedAudioTags % 1 !== 0 ||
        !Number.isFinite(numberOfSharedAudioTags) ||
        Number.isNaN(numberOfSharedAudioTags) ||
        numberOfSharedAudioTags < 0) {
        throw new TypeError(`'numberOfSharedAudioTags' must be an integer but got '${numberOfSharedAudioTags}' instead`);
    }
    (0, validate_playbackrate_js_1.validatePlaybackRate)(currentPlaybackRate);
    (0, react_1.useEffect)(() => {
        emitter.dispatchRateChange(currentPlaybackRate);
    }, [emitter, currentPlaybackRate]);
    (0, react_1.useEffect)(() => {
        setCurrentPlaybackRate(playbackRate);
    }, [playbackRate]);
    (0, react_1.useImperativeHandle)(ref, () => rootRef.current, []);
    const timelineContextValue = (0, react_1.useMemo)(() => {
        return {
            frame,
            playing,
            rootId,
            shouldRegisterSequences: false,
            playbackRate: currentPlaybackRate,
            imperativePlaying,
            setPlaybackRate: (rate) => {
                setCurrentPlaybackRate(rate);
            },
            audioAndVideoTags,
        };
    }, [frame, currentPlaybackRate, playing, rootId]);
    const setTimelineContextValue = (0, react_1.useMemo)(() => {
        return {
            setFrame,
            setPlaying,
        };
    }, [setFrame]);
    const passedInputProps = (0, react_1.useMemo)(() => {
        return inputProps !== null && inputProps !== void 0 ? inputProps : {};
    }, [inputProps]);
    if (typeof window !== 'undefined') {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, react_1.useLayoutEffect)(() => {
            // Inject CSS only on client, and also only after the Player has hydrated
            remotion_1.Internals.CSSUtils.injectCSS(remotion_1.Internals.CSSUtils.makeDefaultCSS(`.${player_css_classname_js_1.PLAYER_CSS_CLASSNAME}`, '#fff'));
        }, []);
    }
    const actualInputProps = (0, react_1.useMemo)(() => inputProps !== null && inputProps !== void 0 ? inputProps : {}, [inputProps]);
    return ((0, jsx_runtime_1.jsx)(remotion_1.Internals.IsPlayerContextProvider, { children: (0, jsx_runtime_1.jsx)(SharedPlayerContext_js_1.SharedPlayerContexts, { timelineContext: timelineContextValue, component: component, compositionHeight: compositionHeight, compositionWidth: compositionWidth, durationInFrames: durationInFrames, fps: fps, inputProps: actualInputProps, numberOfSharedAudioTags: numberOfSharedAudioTags, initiallyMuted: initiallyMuted, children: (0, jsx_runtime_1.jsx)(remotion_1.Internals.Timeline.SetTimelineContext.Provider, { value: setTimelineContextValue, children: (0, jsx_runtime_1.jsx)(emitter_context_js_1.PlayerEventEmitterContext.Provider, { value: emitter, children: (0, jsx_runtime_1.jsx)(PlayerUI_js_1.default, { ref: rootRef, renderLoading: renderLoading, autoPlay: Boolean(autoPlay), loop: Boolean(loop), controls: Boolean(controls), errorFallback: errorFallback, style: style, inputProps: passedInputProps, allowFullscreen: Boolean(allowFullscreen), moveToBeginningWhenEnded: Boolean(moveToBeginningWhenEnded), clickToPlay: typeof clickToPlay === 'boolean'
                            ? clickToPlay
                            : Boolean(controls), showVolumeControls: Boolean(showVolumeControls), doubleClickToFullscreen: Boolean(doubleClickToFullscreen), spaceKeyToPlayOrPause: Boolean(spaceKeyToPlayOrPause), playbackRate: currentPlaybackRate, className: className !== null && className !== void 0 ? className : undefined, showPosterWhenUnplayed: Boolean(showPosterWhenUnplayed), showPosterWhenEnded: Boolean(showPosterWhenEnded), showPosterWhenPaused: Boolean(showPosterWhenPaused), renderPoster: renderPoster, inFrame: inFrame !== null && inFrame !== void 0 ? inFrame : null, outFrame: outFrame !== null && outFrame !== void 0 ? outFrame : null, initiallyShowControls: initiallyShowControls !== null && initiallyShowControls !== void 0 ? initiallyShowControls : true, renderFullscreen: renderFullscreenButton !== null && renderFullscreenButton !== void 0 ? renderFullscreenButton : null, renderPlayPauseButton: renderPlayPauseButton !== null && renderPlayPauseButton !== void 0 ? renderPlayPauseButton : null, alwaysShowControls: alwaysShowControls, showPlaybackRateControl: showPlaybackRateControl }) }) }) }) }));
};
const forward = react_1.forwardRef;
/**
 * @description A component which can be rendered in a regular React App (for example: Create React App, Next.js) to display a Remotion video.
 * @see [Documentation](https://www.remotion.dev/docs/player/player)
 */
exports.Player = forward(PlayerFn);
