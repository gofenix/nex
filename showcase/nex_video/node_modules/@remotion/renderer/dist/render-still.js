"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderStill = exports.internalRenderStill = void 0;
const node_fs_1 = __importStar(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const remotion_1 = require("remotion");
const browser_1 = require("./browser");
const TimeoutSettings_1 = require("./browser/TimeoutSettings");
const convert_to_positive_frame_index_1 = require("./convert-to-positive-frame-index");
const ensure_output_directory_1 = require("./ensure-output-directory");
const handle_javascript_exception_1 = require("./error-handling/handle-javascript-exception");
const find_closest_package_json_1 = require("./find-closest-package-json");
const image_format_1 = require("./image-format");
const jpeg_quality_1 = require("./jpeg-quality");
const make_cancel_signal_1 = require("./make-cancel-signal");
const open_browser_1 = require("./open-browser");
const overwrite_1 = require("./overwrite");
const prepare_server_1 = require("./prepare-server");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const seek_to_frame_1 = require("./seek-to-frame");
const set_props_and_env_1 = require("./set-props-and-env");
const take_frame_and_compose_1 = require("./take-frame-and-compose");
const validate_puppeteer_timeout_1 = require("./validate-puppeteer-timeout");
const validate_scale_1 = require("./validate-scale");
const logger_1 = require("./logger");
const innerRenderStill = async ({ composition, imageFormat = image_format_1.DEFAULT_STILL_IMAGE_FORMAT, serveUrl, puppeteerInstance, onError, inputProps, envVariables, output, frame = 0, overwrite, browserExecutable, timeoutInMilliseconds, chromiumOptions, scale, proxyPort, cancelSignal, jpegQuality, onBrowserLog, compositor, sourceMapContext, downloadMap, logLevel, indent, }) => {
    remotion_1.Internals.validateDimension(composition.height, 'height', 'in the `config` object passed to `renderStill()`');
    remotion_1.Internals.validateDimension(composition.width, 'width', 'in the `config` object passed to `renderStill()`');
    remotion_1.Internals.validateFps(composition.fps, 'in the `config` object of `renderStill()`', false);
    remotion_1.Internals.validateDurationInFrames(composition.durationInFrames, {
        component: 'in the `config` object passed to `renderStill()`',
        allowFloats: false,
    });
    (0, image_format_1.validateStillImageFormat)(imageFormat);
    remotion_1.Internals.validateFrame({
        frame,
        durationInFrames: composition.durationInFrames,
        allowFloats: false,
    });
    const stillFrame = (0, convert_to_positive_frame_index_1.convertToPositiveFrameIndex)({
        durationInFrames: composition.durationInFrames,
        frame,
    });
    (0, validate_puppeteer_timeout_1.validatePuppeteerTimeout)(timeoutInMilliseconds);
    (0, validate_scale_1.validateScale)(scale);
    output =
        typeof output === 'string' ? node_path_1.default.resolve(process.cwd(), output) : null;
    (0, jpeg_quality_1.validateJpegQuality)(jpegQuality);
    if (output) {
        if (node_fs_1.default.existsSync(output)) {
            if (!overwrite) {
                throw new Error(`Cannot render still - "overwrite" option was set to false, but the output destination ${output} already exists.`);
            }
            const stat = (0, node_fs_1.statSync)(output);
            if (!stat.isFile()) {
                throw new Error(`The output location ${output} already exists, but is not a file, but something else (e.g. folder). Cannot save to it.`);
            }
        }
        (0, ensure_output_directory_1.ensureOutputDirectory)(output);
    }
    const browserInstance = puppeteerInstance !== null && puppeteerInstance !== void 0 ? puppeteerInstance : (await (0, open_browser_1.internalOpenBrowser)({
        browser: browser_1.DEFAULT_BROWSER,
        browserExecutable,
        chromiumOptions,
        forceDeviceScaleFactor: scale,
        indent,
        viewport: null,
        logLevel,
    }));
    const page = await browserInstance.newPage(sourceMapContext, logLevel, indent);
    await page.setViewport({
        width: composition.width,
        height: composition.height,
        deviceScaleFactor: scale,
    });
    const errorCallback = (err) => {
        onError(err);
        cleanup();
    };
    const cleanUpJSException = (0, handle_javascript_exception_1.handleJavascriptException)({
        page,
        onError: errorCallback,
        frame: null,
    });
    const logCallback = (log) => {
        onBrowserLog === null || onBrowserLog === void 0 ? void 0 : onBrowserLog({
            stackTrace: log.stackTrace(),
            text: log.text,
            type: log.type,
        });
    };
    const cleanup = async () => {
        cleanUpJSException();
        page.off('console', logCallback);
        if (puppeteerInstance) {
            await page.close();
        }
        else {
            browserInstance.close(true, logLevel, indent).catch((err) => {
                console.log('Unable to close browser', err);
            });
        }
    };
    cancelSignal === null || cancelSignal === void 0 ? void 0 : cancelSignal(() => {
        cleanup();
    });
    if (onBrowserLog) {
        page.on('console', logCallback);
    }
    await (0, set_props_and_env_1.setPropsAndEnv)({
        inputProps,
        envVariables,
        page,
        serveUrl,
        initialFrame: stillFrame,
        timeoutInMilliseconds,
        proxyPort,
        retriesRemaining: 2,
        audioEnabled: false,
        videoEnabled: true,
    });
    await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        // eslint-disable-next-line max-params
        pageFunction: (id, props, durationInFrames, fps, height, width) => {
            window.remotion_setBundleMode({
                type: 'composition',
                compositionName: id,
                props,
                compositionDurationInFrames: durationInFrames,
                compositionFps: fps,
                compositionHeight: height,
                compositionWidth: width,
            });
        },
        args: [
            composition.id,
            composition.props,
            composition.durationInFrames,
            composition.fps,
            composition.height,
            composition.width,
        ],
        frame: null,
        page,
    });
    await (0, seek_to_frame_1.seekToFrame)({ frame: stillFrame, page, composition: composition.id });
    const { buffer } = await (0, take_frame_and_compose_1.takeFrameAndCompose)({
        frame: stillFrame,
        freePage: page,
        height: composition.height,
        width: composition.width,
        imageFormat,
        scale,
        output,
        jpegQuality,
        wantsBuffer: !output,
        compositor,
        downloadMap,
    });
    await cleanup();
    return { buffer: output ? null : buffer };
};
const internalRenderStill = (options) => {
    const cleanup = [];
    const happyPath = new Promise((resolve, reject) => {
        const onError = (err) => reject(err);
        (0, prepare_server_1.makeOrReuseServer)(options.server, {
            webpackConfigOrServeUrl: options.serveUrl,
            port: options.port,
            remotionRoot: (0, find_closest_package_json_1.findRemotionRoot)(),
            concurrency: 1,
            logLevel: options.logLevel,
            indent: options.indent,
        }, {
            onDownload: options.onDownload,
            onError,
        })
            .then(({ server, cleanupServer }) => {
            cleanup.push(() => cleanupServer(false));
            const { serveUrl, offthreadPort, compositor, sourceMap, downloadMap } = server;
            return innerRenderStill({
                ...options,
                serveUrl,
                onError,
                proxyPort: offthreadPort,
                compositor,
                sourceMapContext: sourceMap,
                downloadMap,
            });
        })
            .then((res) => resolve(res))
            .catch((err) => reject(err))
            .finally(() => {
            cleanup.forEach((c) => {
                c();
            });
        });
    });
    return Promise.race([
        happyPath,
        new Promise((_resolve, reject) => {
            var _a;
            (_a = options.cancelSignal) === null || _a === void 0 ? void 0 : _a.call(options, () => {
                reject(new Error(make_cancel_signal_1.cancelErrorMessages.renderStill));
            });
        }),
    ]);
};
exports.internalRenderStill = internalRenderStill;
/**
 *
 * @description Render a still frame from a composition
 * @see [Documentation](https://www.remotion.dev/docs/renderer/render-still)
 */
const renderStill = (options) => {
    var _a;
    const { composition, serveUrl, browserExecutable, cancelSignal, chromiumOptions, dumpBrowserLogs, envVariables, frame, imageFormat, inputProps, jpegQuality, onBrowserLog, onDownload, output, overwrite, port, puppeteerInstance, scale, timeoutInMilliseconds, verbose, quality, } = options;
    if (typeof jpegQuality !== 'undefined' && imageFormat !== 'jpeg') {
        throw new Error("You can only pass the `quality` option if `imageFormat` is 'jpeg'.");
    }
    if (quality) {
        console.warn('Passing `quality()` to `renderStill` is deprecated. Use `jpegQuality` instead.');
    }
    return (0, exports.internalRenderStill)({
        composition,
        browserExecutable: browserExecutable !== null && browserExecutable !== void 0 ? browserExecutable : null,
        cancelSignal: cancelSignal !== null && cancelSignal !== void 0 ? cancelSignal : null,
        chromiumOptions: chromiumOptions !== null && chromiumOptions !== void 0 ? chromiumOptions : {},
        envVariables: envVariables !== null && envVariables !== void 0 ? envVariables : {},
        frame: frame !== null && frame !== void 0 ? frame : 0,
        imageFormat: imageFormat !== null && imageFormat !== void 0 ? imageFormat : image_format_1.DEFAULT_STILL_IMAGE_FORMAT,
        indent: false,
        inputProps: inputProps !== null && inputProps !== void 0 ? inputProps : {},
        jpegQuality: (_a = jpegQuality !== null && jpegQuality !== void 0 ? jpegQuality : quality) !== null && _a !== void 0 ? _a : jpeg_quality_1.DEFAULT_JPEG_QUALITY,
        onBrowserLog: onBrowserLog !== null && onBrowserLog !== void 0 ? onBrowserLog : null,
        onDownload: onDownload !== null && onDownload !== void 0 ? onDownload : null,
        output: output !== null && output !== void 0 ? output : null,
        overwrite: overwrite !== null && overwrite !== void 0 ? overwrite : overwrite_1.DEFAULT_OVERWRITE,
        port: port !== null && port !== void 0 ? port : null,
        puppeteerInstance: puppeteerInstance !== null && puppeteerInstance !== void 0 ? puppeteerInstance : null,
        scale: scale !== null && scale !== void 0 ? scale : 1,
        server: undefined,
        serveUrl,
        timeoutInMilliseconds: timeoutInMilliseconds !== null && timeoutInMilliseconds !== void 0 ? timeoutInMilliseconds : TimeoutSettings_1.DEFAULT_TIMEOUT,
        logLevel: verbose || dumpBrowserLogs ? 'verbose' : (0, logger_1.getLogLevel)(),
    });
};
exports.renderStill = renderStill;
