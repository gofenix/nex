"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.callCompositor = exports.compose = exports.composeWithoutCache = exports.serializeCommand = void 0;
const node_child_process_1 = require("node:child_process");
const node_crypto_1 = require("node:crypto");
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const call_ffmpeg_1 = require("../call-ffmpeg");
const get_executable_path_1 = require("./get-executable-path");
const make_nonce_1 = require("./make-nonce");
const getCompositorHash = ({ ...input }) => {
    return (0, node_crypto_1.createHash)('sha256').update(JSON.stringify(input)).digest('base64');
};
const serializeCommand = (command, params) => {
    return {
        nonce: (0, make_nonce_1.makeNonce)(),
        payload: {
            type: command,
            params,
        },
    };
};
exports.serializeCommand = serializeCommand;
const composeWithoutCache = async ({ height, width, layers, output, imageFormat, compositor, }) => {
    await compositor.executeCommand('Compose', {
        height,
        width,
        layers,
        output,
        output_format: imageFormat,
    });
};
exports.composeWithoutCache = composeWithoutCache;
const compose = async ({ height, width, layers, output, downloadMap, imageFormat, compositor, }) => {
    const hash = getCompositorHash({ height, width, layers, imageFormat });
    if (downloadMap.compositorCache[hash]) {
        await (0, promises_1.copyFile)(downloadMap.compositorCache[hash], output);
        return;
    }
    await (0, exports.composeWithoutCache)({
        compositor,
        height,
        imageFormat,
        layers,
        output,
        width,
    });
    downloadMap.compositorCache[hash] = output;
};
exports.compose = compose;
const callCompositor = (payload) => {
    return new Promise((resolve, reject) => {
        const execPath = (0, get_executable_path_1.getExecutablePath)('compositor');
        if (!process.env.READ_ONLY_FS) {
            (0, node_fs_1.chmodSync)(execPath, 0o755);
        }
        const child = (0, node_child_process_1.spawn)(execPath, [payload], (0, call_ffmpeg_1.dynamicLibraryPathOptions)());
        const stderrChunks = [];
        child.stderr.on('data', (d) => stderrChunks.push(d));
        child.on('close', (code) => {
            if (code === 0) {
                resolve();
            }
            else {
                const message = Buffer.concat(stderrChunks).toString('utf-8');
                try {
                    // Try to see if the error is a JSON
                    const parsed = JSON.parse(message);
                    const msg = `Compositor error: ${parsed.error}`;
                    const err = new Error(`${msg}\n${parsed.backtrace}`);
                    reject(err);
                }
                catch (err) {
                    reject(new Error(`Compositor panicked: ${message}`));
                }
            }
        });
        if (child.stdin.closed) {
            reject(new Error('Compositor stdin closed unexpectedly,' +
                Buffer.concat(stderrChunks).toString('utf-8')));
            return;
        }
        child.stdin.write(payload);
        child.stdin.end();
    });
};
exports.callCompositor = callCompositor;
