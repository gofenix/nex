"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startCompositor = exports.startLongRunningCompositor = exports.getIdealMaximumFrameCacheItems = void 0;
const node_child_process_1 = require("node:child_process");
const node_fs_1 = require("node:fs");
const node_os_1 = __importDefault(require("node:os"));
const call_ffmpeg_1 = require("../call-ffmpeg");
const get_concurrency_1 = require("../get-concurrency");
const logger_1 = require("../logger");
const compose_1 = require("./compose");
const get_executable_path_1 = require("./get-executable-path");
const make_nonce_1 = require("./make-nonce");
const log_level_1 = require("../log-level");
const getIdealMaximumFrameCacheItems = () => {
    const freeMemory = node_os_1.default.freemem();
    // Assuming 1 frame is approximately 6MB
    // Assuming only half the available memory should be used
    const max = Math.floor(freeMemory / (1024 * 1024 * 6));
    // Never store more than 2000 frames
    // But 500 is needed even if it's going to swap
    return Math.max(500, Math.min(max, 2000));
};
exports.getIdealMaximumFrameCacheItems = getIdealMaximumFrameCacheItems;
const startLongRunningCompositor = (maximumFrameCacheItems, logLevel, indent) => {
    return (0, exports.startCompositor)('StartLongRunningProcess', {
        concurrency: (0, get_concurrency_1.getActualConcurrency)(null),
        maximum_frame_cache_items: maximumFrameCacheItems,
        verbose: (0, log_level_1.isEqualOrBelowLogLevel)(logLevel, 'verbose'),
    }, logLevel, indent);
};
exports.startLongRunningCompositor = startLongRunningCompositor;
const startCompositor = (type, payload, logLevel, indent) => {
    var _a;
    const bin = (0, get_executable_path_1.getExecutablePath)('compositor');
    if (!process.env.READ_ONLY_FS) {
        (0, node_fs_1.chmodSync)(bin, 0o755);
    }
    const fullCommand = (0, compose_1.serializeCommand)(type, payload);
    const child = (0, node_child_process_1.spawn)(bin, [JSON.stringify(fullCommand)], (0, call_ffmpeg_1.dynamicLibraryPathOptions)());
    const stderrChunks = [];
    let outputBuffer = Buffer.from('');
    const separator = Buffer.from('remotion_buffer:');
    const waiters = new Map();
    const onMessage = (statusType, nonce, data) => {
        if (nonce === '0') {
            logger_1.Log.verboseAdvanced({ indent, logLevel, tag: 'compositor' }, data.toString('utf8'));
        }
        if (waiters.has(nonce)) {
            if (statusType === 'error') {
                try {
                    const parsed = JSON.parse(data.toString('utf8'));
                    waiters.get(nonce).reject(new Error(`Compositor error: ${parsed.error}\n${parsed.backtrace}`));
                }
                catch (err) {
                    waiters.get(nonce).reject(new Error(data.toString('utf8')));
                }
            }
            else {
                waiters.get(nonce).resolve(data);
            }
            waiters.delete(nonce);
        }
    };
    let runningStatus = { type: 'running' };
    let missingData = null;
    const processInput = () => {
        let separatorIndex = outputBuffer.indexOf(separator);
        if (separatorIndex === -1) {
            return;
        }
        separatorIndex += separator.length;
        let nonceString = '';
        let lengthString = '';
        let statusString = '';
        // Each message from Rust is prefixed with `remotion_buffer;{[nonce]}:{[length]}`
        // Let's read the buffer to extract the nonce, and if the full length is available,
        // we'll extract the data and pass it to the callback.
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const nextDigit = outputBuffer[separatorIndex];
            // 0x3a is the character ":"
            if (nextDigit === 0x3a) {
                separatorIndex++;
                break;
            }
            separatorIndex++;
            nonceString += String.fromCharCode(nextDigit);
        }
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const nextDigit = outputBuffer[separatorIndex];
            if (nextDigit === 0x3a) {
                separatorIndex++;
                break;
            }
            separatorIndex++;
            lengthString += String.fromCharCode(nextDigit);
        }
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const nextDigit = outputBuffer[separatorIndex];
            if (nextDigit === 0x3a) {
                break;
            }
            separatorIndex++;
            statusString += String.fromCharCode(nextDigit);
        }
        const length = Number(lengthString);
        const status = Number(statusString);
        const dataLength = outputBuffer.length - separatorIndex - 1;
        if (dataLength < length) {
            missingData = {
                dataMissing: length - dataLength,
            };
            return;
        }
        const data = outputBuffer.subarray(separatorIndex + 1, separatorIndex + 1 + Number(lengthString));
        onMessage(status === 1 ? 'error' : 'success', nonceString, data);
        missingData = null;
        outputBuffer = outputBuffer.subarray(separatorIndex + Number(lengthString) + 1);
        processInput();
    };
    let unprocessedBuffers = [];
    child.stdout.on('data', (data) => {
        unprocessedBuffers.push(data);
        const separatorIndex = data.indexOf(separator);
        if (separatorIndex === -1) {
            if (missingData) {
                missingData.dataMissing -= data.length;
            }
            if (!missingData || missingData.dataMissing > 0) {
                return;
            }
        }
        unprocessedBuffers.unshift(outputBuffer);
        outputBuffer = Buffer.concat(unprocessedBuffers);
        unprocessedBuffers = [];
        processInput();
    });
    child.stderr.on('data', (data) => {
        stderrChunks.push(data);
    });
    let resolve = null;
    let reject = null;
    child.on('close', (code) => {
        const waitersToKill = Array.from(waiters.values());
        if (code === 0) {
            runningStatus = { type: 'quit-without-error' };
            resolve === null || resolve === void 0 ? void 0 : resolve();
            for (const waiter of waitersToKill) {
                waiter.reject(new Error(`Compositor already quit`));
            }
            waiters.clear();
        }
        else {
            const errorMessage = Buffer.concat(stderrChunks).toString('utf-8');
            runningStatus = { type: 'quit-with-error', error: errorMessage };
            const error = new Error(`Compositor panicked: ${errorMessage}`);
            for (const waiter of waitersToKill) {
                waiter.reject(error);
            }
            waiters.clear();
            reject === null || reject === void 0 ? void 0 : reject(error);
        }
    });
    return {
        waitForDone: () => {
            return new Promise((res, rej) => {
                if (runningStatus.type === 'quit-without-error') {
                    rej(new Error('Compositor already quit'));
                    return;
                }
                if (runningStatus.type === 'quit-with-error') {
                    rej(new Error(`Compositor already quit: ${runningStatus.error}`));
                    return;
                }
                resolve = res;
                reject = rej;
            });
        },
        finishCommands: () => {
            if (runningStatus.type === 'quit-with-error') {
                throw new Error(`Compositor already quit: ${runningStatus.error}`);
            }
            if (runningStatus.type === 'quit-without-error') {
                throw new Error('Compositor already quit');
            }
            child.stdin.write('EOF\n');
        },
        executeCommand: (command, params) => {
            if (runningStatus.type === 'quit-without-error') {
                throw new Error('Compositor already quit');
            }
            if (runningStatus.type === 'quit-with-error') {
                throw new Error(`Compositor quit: ${runningStatus.error}`);
            }
            return new Promise((_resolve, _reject) => {
                const nonce = (0, make_nonce_1.makeNonce)();
                const composed = {
                    nonce,
                    payload: {
                        type: command,
                        params,
                    },
                };
                child.stdin.write(JSON.stringify(composed) + '\n');
                waiters.set(nonce, {
                    resolve: _resolve,
                    reject: _reject,
                });
            });
        },
        pid: (_a = child.pid) !== null && _a !== void 0 ? _a : null,
    };
};
exports.startCompositor = startCompositor;
