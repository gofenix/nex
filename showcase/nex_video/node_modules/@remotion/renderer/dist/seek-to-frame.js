"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.seekToFrame = exports.waitForReady = void 0;
const symbolicateable_error_1 = require("./error-handling/symbolicateable-error");
const parse_browser_error_stack_1 = require("./parse-browser-error-stack");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const waitForReady = (page) => {
    return Promise.race([
        new Promise((_, reject) => {
            page.on("disposed" /* PageEmittedEvents.Disposed */, () => {
                reject(new Error('Target closed (page disposed)'));
            });
        }),
        new Promise((_, reject) => {
            page.browser.on("closed-silent" /* BrowserEmittedEvents.ClosedSilent */, () => {
                reject(new Error('Target closed'));
            });
        }),
        page
            .mainFrame()
            ._mainWorld.waitForFunction(page.browser, 'window.remotion_renderReady === true')
            .catch((err) => {
            throw err;
        }),
        page
            .mainFrame()
            ._mainWorld.waitForFunction(page.browser, 'window.remotion_cancelledError !== undefined')
            .then(() => {
            return (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
                pageFunction: () => window.remotion_cancelledError,
                args: [],
                frame: null,
                page,
            });
        })
            .then(({ value: val }) => {
            if (typeof val !== 'string') {
                throw val;
            }
            throw new symbolicateable_error_1.SymbolicateableError({
                frame: null,
                stack: val,
                name: 'CancelledError',
                message: val.split('\n')[0],
                stackFrame: (0, parse_browser_error_stack_1.parseStack)(val.split('\n')),
            });
        }),
    ]);
};
exports.waitForReady = waitForReady;
const seekToFrame = async ({ frame, page, composition, }) => {
    await (0, exports.waitForReady)(page);
    await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        pageFunction: (f, c) => {
            window.remotion_setFrame(f, c);
        },
        args: [frame, composition],
        frame,
        page,
    });
    await (0, exports.waitForReady)(page);
    await page.evaluateHandle('document.fonts.ready');
};
exports.seekToFrame = seekToFrame;
