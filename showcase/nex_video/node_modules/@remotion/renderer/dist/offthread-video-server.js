"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OffthreadVideoServerEmitter = exports.startOffthreadVideoServer = exports.extractUrlAndSourceFromUrl = void 0;
const node_url_1 = require("node:url");
const download_and_map_assets_to_file_1 = require("./assets/download-and-map-assets-to-file");
const compositor_1 = require("./compositor/compositor");
const log_level_1 = require("./log-level");
const extractUrlAndSourceFromUrl = (url) => {
    const parsed = new URL(url, 'http://localhost');
    const query = parsed.search;
    if (!query.trim()) {
        throw new Error('Expected query from ' + url);
    }
    const params = new node_url_1.URLSearchParams(query);
    const src = params.get('src');
    if (!src) {
        throw new Error('Did not pass `src` parameter');
    }
    const time = params.get('time');
    if (!time) {
        throw new Error('Did not get `time` parameter');
    }
    const transparent = params.get('transparent');
    return {
        src,
        time: parseFloat(time),
        transparent: transparent === 'true',
    };
};
exports.extractUrlAndSourceFromUrl = extractUrlAndSourceFromUrl;
const startOffthreadVideoServer = ({ downloadMap, concurrency, logLevel, indent, }) => {
    const events = new OffthreadVideoServerEmitter();
    const compositor = (0, compositor_1.startCompositor)('StartLongRunningProcess', {
        concurrency,
        maximum_frame_cache_items: (0, compositor_1.getIdealMaximumFrameCacheItems)(),
        verbose: (0, log_level_1.isEqualOrBelowLogLevel)(logLevel, 'verbose'),
    }, logLevel, indent);
    return {
        close: () => {
            compositor.finishCommands();
            return compositor.waitForDone();
        },
        listener: (req, res) => {
            if (!req.url) {
                throw new Error('Request came in without URL');
            }
            if (!req.url.startsWith('/proxy')) {
                res.writeHead(404);
                res.end();
                return;
            }
            const { src, time, transparent } = (0, exports.extractUrlAndSourceFromUrl)(req.url);
            res.setHeader('access-control-allow-origin', '*');
            if (transparent) {
                res.setHeader('content-type', `image/png`);
            }
            else {
                res.setHeader('content-type', `image/bmp`);
            }
            // Handling this case on Lambda:
            // https://support.google.com/chrome/a/answer/7679408?hl=en
            // Chrome sends Private Network Access preflights for subresources
            if (req.method === 'OPTIONS') {
                res.statusCode = 200;
                if (req.headers['access-control-request-private-network']) {
                    res.setHeader('Access-Control-Allow-Private-Network', 'true');
                }
                res.end();
                return;
            }
            (0, download_and_map_assets_to_file_1.downloadAsset)({ src, emitter: events, downloadMap })
                .then((to) => {
                return compositor.executeCommand('ExtractFrame', {
                    input: to,
                    time,
                    transparent,
                });
            })
                .then((readable) => {
                if (!readable) {
                    throw new Error('no readable from ffmpeg');
                }
                res.writeHead(200);
                res.write(readable);
                res.end();
            })
                .catch((err) => {
                res.writeHead(500);
                res.end();
                events.dispatchError(err);
                console.log('Error occurred', err);
            });
        },
        compositor,
        events,
    };
};
exports.startOffthreadVideoServer = startOffthreadVideoServer;
class OffthreadVideoServerEmitter {
    constructor() {
        this.listeners = {
            error: [],
            progress: [],
            download: [],
        };
    }
    addEventListener(name, callback) {
        this.listeners[name].push(callback);
        return () => {
            this.removeEventListener(name, callback);
        };
    }
    removeEventListener(name, callback) {
        this.listeners[name] = this.listeners[name].filter((l) => l !== callback);
    }
    dispatchEvent(dispatchName, context) {
        this.listeners[dispatchName].forEach((callback) => {
            callback({ detail: context });
        });
    }
    dispatchError(error) {
        this.dispatchEvent('error', {
            error,
        });
    }
    dispatchDownloadProgress(src, percent, downloaded, totalSize) {
        this.dispatchEvent('progress', {
            downloaded,
            percent,
            totalSize,
            src,
        });
    }
    dispatchDownload(src) {
        this.dispatchEvent('download', {
            src,
        });
    }
}
exports.OffthreadVideoServerEmitter = OffthreadVideoServerEmitter;
