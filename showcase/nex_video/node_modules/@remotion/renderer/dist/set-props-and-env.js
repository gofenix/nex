"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setPropsAndEnv = void 0;
const version_1 = require("remotion/version");
const TimeoutSettings_1 = require("./browser/TimeoutSettings");
const normalize_serve_url_1 = require("./normalize-serve-url");
const puppeteer_evaluate_1 = require("./puppeteer-evaluate");
const redirect_status_codes_1 = require("./redirect-status-codes");
const validate_puppeteer_timeout_1 = require("./validate-puppeteer-timeout");
const innerSetPropsAndEnv = async ({ inputProps, envVariables, page, serveUrl, initialFrame, timeoutInMilliseconds, proxyPort, retriesRemaining, audioEnabled, videoEnabled, }) => {
    (0, validate_puppeteer_timeout_1.validatePuppeteerTimeout)(timeoutInMilliseconds);
    const actualTimeout = timeoutInMilliseconds !== null && timeoutInMilliseconds !== void 0 ? timeoutInMilliseconds : TimeoutSettings_1.DEFAULT_TIMEOUT;
    page.setDefaultTimeout(actualTimeout);
    page.setDefaultNavigationTimeout(actualTimeout);
    const urlToVisit = (0, normalize_serve_url_1.normalizeServeUrl)(serveUrl);
    await page.evaluateOnNewDocument((timeout) => {
        window.remotion_puppeteerTimeout = timeout;
    }, actualTimeout);
    if (typeof inputProps === 'string') {
        throw new Error('Input props should be an object, not a string.');
    }
    if (inputProps) {
        await page.evaluateOnNewDocument((input) => {
            window.remotion_inputProps = input;
        }, JSON.stringify(inputProps));
    }
    if (envVariables) {
        await page.evaluateOnNewDocument((input) => {
            window.remotion_envVariables = input;
        }, JSON.stringify(envVariables));
    }
    await page.evaluateOnNewDocument((key) => {
        window.remotion_initialFrame = key;
    }, initialFrame);
    await page.evaluateOnNewDocument((port) => {
        window.remotion_proxyPort = port;
    }, proxyPort);
    await page.evaluateOnNewDocument((enabled) => {
        window.remotion_audioEnabled = enabled;
    }, audioEnabled);
    await page.evaluateOnNewDocument((enabled) => {
        window.remotion_videoEnabled = enabled;
    }, videoEnabled);
    const pageRes = await page.goto(urlToVisit);
    if (pageRes === null) {
        throw new Error(`Visited "${urlToVisit}" but got no response.`);
    }
    const status = pageRes.status();
    // S3 in rare occasions returns a 500 or 503 error code for GET operations.
    // Usually it is fixed by retrying.
    if (status >= 500 && status <= 504 && retriesRemaining > 0) {
        await new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, 2000);
        });
        return innerSetPropsAndEnv({
            envVariables,
            initialFrame,
            inputProps,
            page,
            proxyPort,
            retriesRemaining: retriesRemaining - 1,
            serveUrl,
            timeoutInMilliseconds,
            audioEnabled,
            videoEnabled,
        });
    }
    if (!redirect_status_codes_1.redirectStatusCodes.every((code) => code !== status)) {
        throw new Error(`Error while getting compositions: Tried to go to ${urlToVisit} but the status code was ${status} instead of 200. Does the site you specified exist?`);
    }
    const isRemotionFn = await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        pageFunction: () => {
            return window.getStaticCompositions;
        },
        args: [],
        frame: null,
        page,
    });
    if (isRemotionFn === undefined) {
        throw new Error(`Error while getting compositions: Tried to go to ${urlToVisit} and verify that it is a Remotion project by checking if window.getStaticCompositions is defined. However, the function was undefined, which indicates that this is not a valid Remotion project. Please check the URL you passed.`);
    }
    const { value: siteVersion } = await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        pageFunction: () => {
            return window.siteVersion;
        },
        args: [],
        frame: null,
        page,
    });
    const { value: remotionVersion } = await (0, puppeteer_evaluate_1.puppeteerEvaluateWithCatch)({
        pageFunction: () => {
            return window.remotion_version;
        },
        args: [],
        frame: null,
        page,
    });
    const requiredVersion = '7';
    if (siteVersion !== requiredVersion) {
        throw new Error(`Incompatible site: When visiting ${urlToVisit}, a bundle was found, but one that is not compatible with this version of Remotion. Found version: ${siteVersion} - Required version: ${requiredVersion}. To resolve this error, please bundle and deploy again.`);
    }
    if (remotionVersion !== version_1.VERSION && process.env.NODE_ENV !== 'test') {
        if (remotionVersion) {
            console.warn(`The site was bundled with version ${remotionVersion} of @remotion/bundler, while @remotion/renderer is on version ${version_1.VERSION}. You may not have the newest bugfixes and features. Re-bundle the site to fix this issue.`);
        }
        else {
            console.warn(`The site was bundled with an old version of Remotion, while @remotion/renderer is on version ${version_1.VERSION}. You may not have the newest bugfixes and features. Re-bundle the site to fix this issue.`);
        }
    }
};
const setPropsAndEnv = (params) => {
    return Promise.race([
        innerSetPropsAndEnv(params),
        new Promise((_, reject) => {
            setTimeout(() => {
                reject(new Error(`Timed out after ${params.timeoutInMilliseconds} while setting up the headless browser. This could be because the you specified takes a long time to load (or network resources that it includes like fonts) or because the browser is not responding. Optimize the site or increase the browser timeout.`));
            }, params.timeoutInMilliseconds);
        }),
    ]);
};
exports.setPropsAndEnv = setPropsAndEnv;
