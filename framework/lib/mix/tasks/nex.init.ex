defmodule Mix.Tasks.Nex.Init do
  @moduledoc """
  Initialize Nex project structure in an existing Elixir project.

  ## Usage

  First create a new Elixir project and add Nex as a dependency:

      mix new my_app
      cd my_app

  Add to mix.exs deps:

      {:nex, "~> 0.1"}

  Then run:

      mix deps.get
      mix nex.init

  ## What it creates

      src/
      ‚îú‚îÄ‚îÄ application.ex    # Application module (if not exists)
      ‚îú‚îÄ‚îÄ layouts.ex        # Layout template
      ‚îú‚îÄ‚îÄ pages/
      ‚îÇ   ‚îî‚îÄ‚îÄ index.ex      # Home page
      ‚îú‚îÄ‚îÄ api/              # API endpoints directory
      ‚îî‚îÄ‚îÄ partials/         # Reusable components directory

  ## Options

      --force    Overwrite existing files
  """

  use Mix.Task

  @shortdoc "Initialize Nex project structure"

  def run(args) do
    {opts, _, _} = OptionParser.parse(args, switches: [force: :boolean])
    force? = opts[:force] || false

    # Get project info from mix.exs
    app_name = Mix.Project.config()[:app] |> to_string()
    module_name = Macro.camelize(app_name)

    Mix.shell().info("\nüöÄ Initializing Nex structure for #{module_name}...\n")

    # Clean up mix new residual files
    cleanup_mix_new_files(app_name)

    # Update mix.exs to include src/ in elixirc_paths and Application module
    update_mix_exs(module_name)

    # Create directory structure
    create_directories()

    # Create template files
    assigns = %{app_name: app_name, module_name: module_name}

    create_file("src/application.ex", application_template(assigns), force?)
    create_file("src/layouts.ex", layouts_template(assigns), force?)
    create_file("src/pages/index.ex", index_template(assigns), force?)
    create_file(".env.example", env_example_template(), force?)

    Mix.shell().info("""

    ‚úÖ Nex initialized successfully!

    Next steps:

        mix nex.dev

    Then open http://localhost:4000 in your browser.
    """)
  end

  defp create_directories do
    dirs = ["src", "src/pages", "src/api", "src/partials"]

    Enum.each(dirs, fn dir ->
      unless File.dir?(dir) do
        File.mkdir_p!(dir)
        Mix.shell().info("  Created: #{dir}/")
      end
    end)
  end

  defp create_file(path, content, force?) do
    if File.exists?(path) and not force? do
      Mix.shell().info("  Skipped: #{path} (already exists, use --force to overwrite)")
    else
      dir = Path.dirname(path)
      File.mkdir_p!(dir)
      File.write!(path, content)
      Mix.shell().info("  Created: #{path}")
    end
  end

  defp cleanup_mix_new_files(app_name) do
    # Remove lib/<app_name>.ex generated by mix new
    lib_file = "lib/#{app_name}.ex"
    if File.exists?(lib_file) do
      File.rm!(lib_file)
      Mix.shell().info("  Removed: #{lib_file} (generated by mix new)")
    end

    # Remove empty lib/ directory
    if File.dir?("lib") and File.ls!("lib") == [] do
      File.rmdir!("lib")
      Mix.shell().info("  Removed: lib/ (empty)")
    end

    # Remove test/ directory
    if File.dir?("test") do
      File.rm_rf!("test")
      Mix.shell().info("  Removed: test/ (not needed for Nex)")
    end
  end

  defp update_mix_exs(module_name) do
    mix_exs = File.read!("mix.exs")

    # Check what needs to be updated
    needs_elixirc_paths = not String.contains?(mix_exs, "elixirc_paths")
    needs_application_mod = not String.contains?(mix_exs, "mod:")

    if needs_elixirc_paths or needs_application_mod do
      updated_mix_exs = mix_exs
        |> maybe_add_elixirc_paths(needs_elixirc_paths)
        |> maybe_add_application_mod(needs_application_mod, module_name)

      File.write!("mix.exs", updated_mix_exs)
    end

    # Always clean up comments and fix Elixir version
    cleanup_mix_exs_comments()
    Mix.shell().info("  Updated: mix.exs")
  end

  defp maybe_add_elixirc_paths(content, false), do: content
  defp maybe_add_elixirc_paths(content, true) do
    # Add elixirc_paths after deps: deps()
    String.replace(
      content,
      "deps: deps()",
      "elixirc_paths: [\"src\"],\n      deps: deps()"
    )
  end

  defp maybe_add_application_mod(content, false, _), do: content
  defp maybe_add_application_mod(content, true, module_name) do
    # Add mod: to application function
    String.replace(
      content,
      "extra_applications: [:logger]",
      "extra_applications: [:logger],\n      mod: {#{module_name}.Application, []}"
    )
  end

  defp cleanup_mix_exs_comments do
    mix_exs = File.read!("mix.exs")

    cleaned = mix_exs
      # Remove mix new comments
      |> String.replace(~r/\s*# Run "mix help.*\n/, "\n")
      # Remove commented deps
      |> String.replace(~r/\s*# \{:dep_from.*\n/, "")
      # Fix Elixir version to 1.18
      |> String.replace(~r/elixir: "~> 1\.\d+"/, "elixir: \"~> 1.18\"")
      # Clean up extra blank lines
      |> String.replace(~r/\n{3,}/, "\n\n")

    File.write!("mix.exs", cleaned)
  end

  # Templates

  defp layouts_template(assigns) do
    """
    defmodule #{assigns.module_name}.Layouts do
      use Nex.Page

      def render(assigns) do
        ~H\"\"\"
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>{@title}</title>
            <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio"></script>
            <script src="https://unpkg.com/htmx.org@2.0.4"></script>
          </head>
          <body class="bg-gray-100 min-h-screen">
            <nav class="bg-white shadow-sm border-b">
              <div class="max-w-4xl mx-auto px-4 py-3">
                <a href="/" class="text-xl font-bold text-blue-600">#{assigns.module_name}</a>
              </div>
            </nav>
            <main class="max-w-4xl mx-auto px-4 py-8">
              {raw(@inner_content)}
            </main>
          </body>
        </html>
        \"\"\"
      end
    end
    """
  end

  defp index_template(assigns) do
    """
    defmodule #{assigns.module_name}.Pages.Index do
      use Nex.Page

      def mount(_params) do
        %{
          title: "Welcome to #{assigns.module_name}",
          message: "Your Nex app is running!"
        }
      end

      def render(assigns) do
        ~H\"\"\"
        <div class="text-center py-12">
          <h1 class="text-4xl font-bold text-gray-800 mb-4">{@message}</h1>
          <p class="text-gray-600 mb-8">
            Edit <code class="bg-gray-200 px-2 py-1 rounded">src/pages/index.ex</code> to get started.
          </p>

          <div class="bg-white rounded-lg p-6 shadow max-w-md mx-auto">
            <h2 class="text-xl font-semibold mb-4">Project Structure</h2>
            <ul class="space-y-2 text-left">
              <li>üìÅ <code>src/pages/</code> - Page components</li>
              <li>üîå <code>src/api/</code> - API endpoints</li>
              <li>üß© <code>src/partials/</code> - Reusable components</li>
              <li>üé® <code>src/layouts.ex</code> - Layout template</li>
            </ul>
          </div>
        </div>
        \"\"\"
      end
    end
    """
  end

  defp application_template(assigns) do
    """
    defmodule #{assigns.module_name}.Application do
      @moduledoc false
      use Application

      @impl true
      def start(_type, _args) do
        children = []
        opts = [strategy: :one_for_one, name: #{assigns.module_name}.Supervisor]
        Supervisor.start_link(children, opts)
      end
    end
    """
  end

  defp env_example_template do
    """
    # Server configuration
    PORT=4000
    HOST=localhost

    # Add your environment variables here
    """
  end
end
