# Nex 框架 v1.0 实施计划

**基于 José Valim 技术评审**
**创建日期**: 2024年12月27日
**目标版本**: v1.0.0

---

## 执行摘要

本文档基于 José Valim 的技术评审报告，制定 Nex 框架 v1.0 的完整实施计划。核心目标是解决评审中识别的架构问题，同时保持框架"极简主义"的设计哲学。

**三大核心目标**:
1. **拆分臃肿的 Handler** - 从 665 行拆分为专注模块
2. **优化 Store 性能** - touch_page 从 O(n) 改为 O(1)
3. **增强可靠性** - CSRF 防护、SSE 错误处理、生产热重载禁用

---

## 一、架构目标与约束

### 1.1 设计原则

| 原则 | 说明 | 约束 |
|------|------|------|
| **极简主义** | 核心代码 < 2000 行 | 禁止引入过度抽象 |
| **约定优于配置** | 文件路径即路由 | 保持现有约定 |
| **HTMX 优先** | 零 JS 交互 | 新功能不强制引入 JS |
| **OTP 合规** | 正确使用监督、GenServer | 必须通过 Dialyzer |
| **向后兼容** | v0.x 用户的迁移路径 | 废弃 API 加 deprecation |

### 1.2 技术约束

```
约束清单:
├── 禁止引入 Phoenix 完整依赖
├── 禁止使用 Ecto（保持轻量）
├── 必须支持 Elixir 1.16+
├── ETS 必须是 :protected（安全）
└── 所有异步操作必须有超时
```

### 1.3 成功标准

- [ ] 核心模块测试覆盖率 > 80%
- [ ] Handler 拆分后任一模块 < 200 行
- [ ] touch_page 从 O(n) → O(1)
- [ ] 通过 Dialyzer 类型检查（零警告）
- [ ] 文档完整性 8/10

---

## 二、任务拆解总览

### 任务依赖图

```
Phase 1: 基础设施 (可以并行)
├── T1.1 拆分 Nex.Handler
├── T1.2 优化 Nex.Store.touch_page
└── T1.3 添加 @spec 类型规范

Phase 2: 安全性增强
├── T2.1 CSRF 防护
├── T2.2 SSE 错误处理完善
└── T2.3 生产环境热重载禁用

Phase 3: 性能优化
├── T3.1 编译时路由缓存
└── T3.2 ETS 并发选项优化

Phase 4: DX 提升
├── T4.1 测试辅助模块
├── T4.2 健康检查端点
└── T4.3 错误处理增强

Phase 5: 文档与发布
├── T5.1 更新 API 文档
├── T5.2 编写迁移指南
└── T5.3 发布 v1.0.0
```

---

## 三、详细任务规格

### Phase 1: 基础设施

#### T1.1 拆分 Nex.Handler 🔴 HIGH PRIORITY

**目标**: 将 665 行的 Handler 拆分为专注模块

**拆解方案**:

```
当前结构 (665 行):
├── 路由解析 (resolve_*)           ~100 行
├── 页面处理 (handle_page_*)       ~150 行
├── API/SSE 处理 (handle_*_*)      ~150 行
├── 响应发送 (send_*)              ~100 行
└── 工具函数 (html_escape, etc)    ~165 行

目标结构:
├── Nex.Handler.Core               # 核心公共函数
├── Nex.Handler.Page               # 页面渲染
├── Nex.Handler.API                # API 端点
├── Nex.Handler.SSE                # SSE 流式
├── Nex.Handler.Error              # 错误处理
└── Nex.Handler.Router             # 路由解析
```

**子任务**:

```
T1.1.1 创建 Nex.Handler.Core 模块
├── 职责: 公共类型定义、html_escape、safe_to_existing_atom
├── 输入: handler.ex 第 629-663 行
├── 输出: lib/nex/handler/core.ex (~40 行)
└── 验收:
    ├── 所有类型定义使用 @type
    ├── html_escape 补全单引号转义
    └── 保留安全 atom 转换逻辑

T1.1.2 创建 Nex.Handler.Router 模块
├── 职责: 路由解析、模块查找
├── 输入: handler.ex 第 433-570 行
├── 输出: lib/nex/handler/router.ex (~80 行)
└── 验收:
    ├── path_to_module_parts/1 可测试
    ├── resolve_page_module/1 可测试
    └── resolve_action/1 可测试

T1.1.3 创建 Nex.Handler.Page 模块
├── 职责: 页面渲染、mount/action 调用
├── 输入: handler.ex 第 268-431 行
├── 输出: lib/nex/handler/page.ex (~100 行)
└── 验收:
    ├── handle_page/3 可测试
    ├── handle_page_render/3 可测试
    └── handle_page_action/3 可测试

T1.1.4 创建 Nex.Handler.API 模块
├── 职责: API 和 SSE 端点处理
├── 输入: handler.ex 第 54-205 行
├── 输出: lib/nex/handler/api.ex (~120 行)
└── 验收:
    ├── handle_api_or_sse/3 可测试
    ├── handle_sse_endpoint/3 可测试
    └── send_sse_stream/3 修复错误处理

T1.1.5 创建 Nex.Handler.Error 模块
├── 职责: 统一错误页面和响应
├── 输入: handler.ex 第 572-627 行
├── 输出: lib/nex/handler/error.ex (~60 行)
└── 验收:
    ├── send_error_page/4 可测试
    ├── send_json_error/3 可测试
    └── 支持自定义错误视图

T1.1.6 重构 Nex.Handler 主模块
├── 职责: 协调各子模块
├── 输入: 重组后的 handler.ex
├── 输出: lib/nex/handler.ex (~80 行)
└── 验收:
    ├── 只保留 handle/1 和 before_send 逻辑
    ├── 使用子模块
    └── 保持 API 兼容

T1.1.7 更新模块导出
├── 职责: 确保向后兼容
├── 输出: lib/nex/handler.ex
└── 验收:
    ├── 原有公共函数仍在
    ├── @doc 指向新模块
    └── deprecation 警告（如需要）
```

**验收标准**:
- [ ] `Nex.Handler` 主模块 < 100 行
- [ ] 每个子模块 < 120 行
- [ ] 保持 100% 向后兼容
- [ ] 所有拆分的函数可独立测试

**技术风险**: 向后兼容性 - 需要完整测试套件

---

#### T1.2 优化 Nex.Store.touch_page 🔴 HIGH PRIORITY

**目标**: 从 O(n) 遍历改为 O(1) 元数据更新

**当前问题**:
```elixir
# 当前: 每次请求遍历该页面所有键
defp touch_page(page_id) do
  :ets.match(@table, {{page_id, :"$1"}, :"$2", :_})
  |> Enum.each(fn [key, value] ->
    :ets.insert(@table, {{page_id, key}, value, new_expires})
  end)
end
```

**方案**: 使用元数据条目存储最后访问时间

```
设计:
├── 原有条目: {{page_id, key}, value, expires_at}
├── 新增条目: {:page_meta, page_id, last_accessed}
└── 清理逻辑: 基于 :page_meta 判断页面是否活跃
```

**子任务**:

```
T1.2.1 设计元数据结构
├── 职责: 定义新的元数据存储格式
├── 设计:
│   # ETS 表结构
│   # { {:page_meta, page_id}, last_accessed }  # 单条元数据
│   # { {page_id, key}, value, expires_at }     # 原有数据
└── 验收:
    ├── 不破坏现有数据
    ├── 支持批量清理过期页面
    └── 读操作不增加开销

T1.2.2 实现 O(1) touch_page
├── 职责: 改为单条元数据更新
├── 输入: store.ex 第 122-133 行
├── 代码:
│   defp touch_page(page_id) do
│     :ets.insert(@table, {:page_meta, page_id, System.system_time(:millisecond)})
│   end
└── 验收:
    ├── 单次 :ets.insert
    └── 测试通过

T1.2.3 优化 cleanup_expired
├── 职责: 基于元数据批量清理
├── 逻辑:
│   # 1. 查找所有过期页面
│   # 2. 批量删除该页面所有条目
│   # 3. 删除元数据
└── 代码:
│   defp cleanup_expired do
│     now = System.system_time(:millisecond)
│     # 查找所有过期页面
│     expired_pages =
│       :ets.select(@table, [{{:page_meta, :"$1", :"$2"}, [{:<, :"$2", now}], [[:'$1']]}])
│
│     Enum.each(expired_pages, fn page_id ->
│       :ets.match_delete(@table, {{page_id, :_}, :_, :_})
│       :ets.delete(@table, {:page_meta, page_id})
│     end)
│   end
└── 验收:
    ├── 清理从 O(n²) → O(k) 其中 k = 过期页面数
    └── 日志输出正确

T1.2.4 添加可选的惰性过期检查
├── 职责: 在 get/2 中检查单个键过期
├── 逻辑:
│   def get(key, default \\ nil) do
│     page_id = get_page_id()
│     case :ets.lookup(@table, {page_id, key}) do
│       [{_, value, expires_at}] ->
│         if expires_at < System.system_time(:millisecond) do
│           :ets.delete(@table, {page_id, key})
│           default
│         else
│           value
│         end
│       [] -> default
│     end
│   end
└── 验收:
    ├── 单个过期键及时清理
    └── 可通过配置禁用
```

**验收标准**:
- [ ] touch_page 从 O(n) → O(1)
- [ ] cleanup_expired 批量删除
- [ ] 内存占用不增加
- [ ] 保持 TTL 语义

**性能影响评估**:
| 操作 | 优化前 | 优化后 |
|------|--------|--------|
| touch_page | O(n) 写 | O(1) 写 |
| cleanup_expired | O(n²) | O(k) |
| get | O(1) | O(1) + 可选惰性清理 |

---

#### T1.3 添加 @spec 类型规范 🟡 MEDIUM PRIORITY

**目标**: 通过 Dialyzer 检查，提升代码可靠性

**子任务**:

```
T1.3.1 为 Nex.Store 添加 @spec
├── 职责: 定义所有公开函数的类型
├── 规格:
│   @spec get(key :: term(), default :: term()) :: term()
│   @spec put(key :: term(), value :: term()) :: term()
│   @spec update(key :: term(), default :: term(), (term() -> term())) :: term()
│   @spec delete(key :: term()) :: :ok
│   @spec clear_page(page_id :: binary()) :: :ok
│   @spec generate_page_id() :: binary()
│   @spec set_page_id(page_id :: binary()) :: :ok
│   @spec get_page_id() :: binary()
│   @spec clear_process_dictionary() :: :ok
└── 验收: Dialyzer 无警告

T1.3.2 为 Nex.Handler 添加 @spec
├── 职责: 定义 Conn 和响应的类型
├── 规格:
│   @spec handle(Plug.Conn.t()) :: Plug.Conn.t()
│   @spec send_error_page(Plug.Conn.t(), integer(), binary(), term()) :: Plug.Conn.t()
└── 验收: Dialyzer 无警告

T1.3.3 为 Nex.SSE 添加 @spec
├── 职责: 定义行为回调的类型
├── 规格:
│   @callback stream(params :: map(), send_fn :: (map() -> :ok)) :: :ok
└── 验收: 实现模块通过类型检查

T1.3.4 创建 dialyzer.exs 配置文件
├── 职责: 配置 Dialyzer 分析
├── 内容:
│   alias: :nex
│   dirs: ["lib"]
│   warnings: [:unknown]
└── 验收: mix dialyzer 通过
```

---

### Phase 2: 安全性增强

#### T2.1 CSRF 防护 🟡 MEDIUM PRIORITY

**目标**: 可选的 CSRF 保护，与 HTMX 集成

**设计**:

```
配置:
config :nex, :csrf_protection, false  # 默认关闭（向后兼容）

启用后:
1. 生成 CSRF token (32 字节加密随机)
2. 存储在 :csrf_token 元数据中
3. 通过 cookie 或请求头传递
4. POST 请求验证
```

**子任务**:

```
T2.1.1 设计 CSRF API
├── 职责: 定义 CSRF 相关函数
├── 位置: lib/nex/csrf.ex (新文件)
├── API:
│   Nex.CSRF.generate_token()
│   Nex.CSRF.validate_token(token)
│   Nex.CSRF.get_token_from_conn(conn)
└── 设计: 参考 Plug.CSRF

T2.1.2 实现 token 生成和验证
├── 职责: 加密安全的 token 处理
├── 依赖: :crypto.strong_rand_bytes/1
└── 验收: token 不可预测

T2.1.3 集成到表单注入
├── 职责: 自动在表单中添加 token
├── 位置: Nex.Handler.Page
└── 逻辑: 检测表单，自动注入隐藏字段

T2.1.4 添加中间件验证
├── 职责: POST 请求验证
├── 位置: Nex.Handler
└── 逻辑: 如果启用，验证 token

T2.1.5 添加配置和文档
├── 职责: 说明如何启用
└── 文档:
    # 启用 CSRF
    config :nex, :csrf_protection, true

    # 自定义排除路径
    config :nex, :csrf_exclude_paths, ["/api/"]
```

**验收标准**:
- [ ] 默认关闭（向后兼容）
- [ ] 启用后有效阻止 CSRF 攻击
- [ ] 与 HTMX 头部请求兼容
- [ ] 可配置排除路径

---

#### T2.2 SSE 错误处理完善 🟡 MEDIUM PRIORITY

**目标**: 修复 catch 块不返回 conn 的问题

**当前问题**:
```elixir
# handler.ex 第 176-205 行
defp send_sse_stream(conn, module, params) do
  try do
    # ...
    conn  # 正常返回
  catch
    :closed -> :ok  # 问题：conn 没有返回！
  end
end
```

**子任务**:

```
T2.2.1 修复 catch 块
├── 职责: 确保 conn 被返回
├── 代码:
│   defp send_sse_stream(conn, module, params) do
│     try do
│       # ... stream logic ...
│       conn
│     catch
│       :closed -> conn  # 返回 conn
│     end
│   end
└── 验收: cleanup callback 执行

T2.2.2 添加 SSE 心跳机制
├── 职责: 防止长连接超时
├── 逻辑:
│   # 每 30 秒发送 ping
│   # 处理客户端断开
└── 代码:
│   defp send_sse_stream(conn, module, params) do
│     ref = make_ref()
│     timer = Process.send_after(self(), {:ping, ref}, 30_000)
│
│     try do
│       apply(module, :stream, [params, fn event ->
│         cancel_timer(timer)
│         timer = Process.send_after(self(), {:ping, ref}, 30_000)
│         # 发送事件...
│       end])
│       conn
│     catch
│       :closed -> conn
│     after
│       cancel_timer(timer)
│     end
│   end
└── 验收: 客户端超时断开时正确处理

T2.2.3 添加通用异常处理
├── 职责: 捕获未预期的异常
├── 逻辑: 记录错误并发送错误事件
└── 代码:
│   catch
│     :closed -> conn
│     kind, reason ->
│       Logger.error("SSE error: #{inspect(kind)} #{inspect(reason)}")
│       send_fn.(%{event: "error", data: "Internal server error"})
│       conn
│   end
```

---

#### T2.3 生产环境热重载禁用 🟢 LOW PRIORITY

**目标**: Nex.Reloader 在生产环境不启动

**子任务**:

```
T2.3.1 修改 Reloader 启动逻辑
├── 职责: 检查 Mix.env()
├── 代码:
│   def init(_opts) do
│     if Mix.env() == :dev do
│       # 正常启动
│       {:ok, watcher_pid} = FileSystem.start_link(...)
│       {:ok, %{watcher: watcher_pid, last_reload: 0}}
│     else
│       # 生产环境不启动
│       {:ok, %{watcher: nil, last_reload: 0}}
│     end
│   end
└── 验收: 生产环境不监听文件

T2.3.2 更新 last_reload_time 逻辑
├── 职责: 生产环境直接返回 0
├── 代码:
│   def last_reload_time do
│     if Mix.env() == :dev do
│       GenServer.call(__MODULE__, :last_reload_time)
│     else
│       0
│     end
│   end
└── 验收: 生产环境无额外开销
```

---

### Phase 3: 性能优化

#### T3.1 编译时路由缓存 🟡 MEDIUM PRIORITY

**目标**: 减少运行时模块解析开销

**设计**:

```
方案: 使用 :ets 作为路由缓存
├── 缓存键: {method, path}
├── 缓存值: {module, function, params_schema}
└── 失效: 在热重载时批量清除
```

**子任务**:

```
T3.1.1 创建路由缓存模块
├── 职责: 管理路由解析缓存
├── 位置: lib/nex/router/cache.ex
├── API:
│   Nex.Router.Cache.get(method, path)
│   Nex.Router.Cache.put(method, path, result)
│   Nex.Router.Cache.invalidate_all()
└── 设计: :ets 表 + 简单封装

T3.1.2 集成到 Handler
├── 职责: 先查缓存，再解析
├── 逻辑:
│   defp resolve_page_module(path) do
│     case Nex.Router.Cache.get(:get, path) do
│       {:hit, result} -> result
│       :miss -> resolve_and_cache(path)
│     end
│   end
└── 验收: 重复路径请求更快

T3.1.3 热重载时清除缓存
├── 职责: 在 Reloader 中清除
├── 逻辑: 编译文件后清除所有缓存
└── 代码:
│   defp reload_file(path, state) do
│     # ... 编译 ...
│     Nex.Router.Cache.invalidate_all()  # 新增
│     # ...
│   end
```

---

#### T3.2 ETS 并发选项优化 🟢 LOW PRIORITY

**目标**: 提升 Store 并发性能

**子任务**:

```
T3.2.1 更新 ETS 选项
├── 职责: 添加并发优化
├── 当前:
│   :ets.new(@table, [:named_table, :public, :set])
├── 改为:
│   :ets.new(@table, [:named_table, :public, :set, read_concurrency: true])
└── 验收: 通过 :ets.i() 确认选项

T3.2.2 添加写时复制优化
├── 职责: 评估是否需要 write_concurrency
└── 决策: 根据压测结果决定是否启用
```

---

### Phase 4: DX 提升

#### T4.1 测试辅助模块 🟡 MEDIUM PRIORITY

**目标**: 类似 Phoenix.ConnTest 的测试工具

**子任务**:

```
T4.1.1 创建 Nex.ConnTest
├── 职责: 提供测试辅助函数
├── 位置: lib/nex/conn_test.ex
├── API:
│   Nex.ConnTest.conn(method, path)
│   Nex.ConnTest.get(conn, path)
│   Nex.ConnTest.post(conn, path, params)
│   Nex.ConnTest.follow_redirect(conn)
└── 设计: 参考 Plug.Test

T4.1.2 添加 Store 测试辅助
├── 职责: 简化 Store 测试
├── API:
│   Nex.ConnTest.with_page_id(page_id, fun)
│   Nex.ConnTest.put_store(key, value)
│   Nex.ConnTest.get_store(key)
└── 代码:
│   defmacro with_page_id(page_id, fun) do
│     quote do
│       Nex.Store.set_page_id(unquote(page_id))
│       try do
│         unquote(fun)
│       after
│         Nex.Store.clear_process_dictionary()
│       end
│     end
│   end

T4.1.3 编写测试示例
├── 职责: 文档化测试用法
└── 文档:
    # test/nex/handler_test.exs
    defmodule Nex.HandlerTest do
      use ExUnit.Case
      import Nex.ConnTest

      test "GET / returns Index page" do
        conn = get(conn("/"), "/")
        assert conn.status == 200
      end
    end
```

---

#### T4.2 健康检查端点 🟢 LOW PRIORITY

**目标**: 生产监控支持

**子任务**:

```
T4.2.1 添加 /nex/health 端点
├── 职责: 返回健康状态
├── 逻辑:
│   GET /nex/health
│   Response: {status: "ok", uptime: ..., memory: ...}
└── 代码:
│   defp handle_health_check(conn) do
│     conn
│     |> put_resp_content_type("application/json")
│     |> send_resp(200, Jason.encode!(%{
│       status: "ok",
│       uptime: :erlang.statistics(:wall_clock),
│       memory: :erlang.memory()
│     }))
│   end

T4.2.2 添加存活探针
├── 职责: K8s liveness probe
└── 端点: GET /nex/live 返回 200
```

---

#### T4.3 错误处理增强 🟡 MEDIUM PRIORITY

**目标**: 更好的错误追踪和恢复

**子任务**:

```
T4.3.1 添加 Telemetry 集成
├── 职责: 发送请求指标
├── 事件:
│   [:nex, :request, :start]
│   [:nex, :request, :stop]
│   [:nex, :request, :exception]
└── 代码:
│   :telemetry.execute([:nex, :request, :stop], %{duration: duration})

T4.3.2 添加请求 ID
├── 职责: 追踪请求链路
├── 依赖: :crypto.strong_rand_bytes(16)
└── 输出: X-Request-Id 响应头

T4.3.3 改进错误日志
├── 职责: 结构化错误日志
└── 格式: JSON，包含 request_id, path, method
```

---

### Phase 5: 文档与发布

#### T5.1 更新 API 文档 🟡 MEDIUM PRIORITY

**目标**: 达到 8/10 完整性

**子任务**:

```
T5.1.1 补充 @moduledoc
├── 职责: 为所有模块添加完整文档
└── 范围: Nex.Handler.*, Nex.Router.*, Nex.Store

T5.1.2 编写架构指南
├── 职责: 说明内部设计
└── 文档: ARCHITECTURE.md

T5.1.3 编写部署指南
├── 职责: 生产部署说明
└── 文档: DEPLOYMENT.md
```

#### T5.2 编写迁移指南 🟡 MEDIUM PRIORITY

**目标**: v0.x → v1.0 迁移帮助

**子任务**:

```
T5.2.1 列出 breaking changes
├── 职责: 识别 API 变化
└── 内容:
    ├── 如果拆分 Handler，需要更新引用
    └── CSRF 默认关闭

T5.2.2 编写迁移脚本
├── 职责: 自动更新常见用法
└── 工具: mix nex.gen.migration

T5.2.3 创建 CHANGELOG.md
├── 职责: 记录所有变更
└── 格式: Keep a Changelog
```

#### T5.3 发布 v1.0.0 🟢 LOW PRIORITY

**目标**: 正式发布

**子任务**:

```
T5.3.1 版本号更新
├── 职责: 更新 mix.exs version
└── 改为: "1.0.0"

T5.3.2 更新依赖版本
├── 职责: 确保依赖兼容
└── 检查: bandit ~> 1.9, plug ~> 1.19

T5.3.3 创建 GitHub Release
├── 职责: 生成发布说明
└── 内容: 链接到迁移指南
```

---

## 四、依赖关系矩阵

```
关键路径:
T1.1 (Handler 拆分) ──→ T4.1 (测试辅助)
                            │
                            ▼
                       T5.2 (迁移指南) ──→ T5.3 (发布)

并行路径:
├── T1.2 (Store 优化) ──→ T3.1 (路由缓存)
│
├── T2.1 (CSRF) ──────→ T2.4 (测试)
│
├── T2.2 (SSE 修复) ──→ T4.3 (Telemetry)
│
└── T3.1 (路由缓存) ──→ T2.3 (热重载禁用)
```

---

## 五、验收检查清单

### 发布前必须完成

- [ ] **所有高优先级任务完成** (T1.1, T1.2, T2.2)
- [ ] **测试覆盖率 > 80%** (核心模块)
- [ ] **Dialyzer 通过** (零警告)
- [ ] **向后兼容** (v0.x API 兼容)
- [ ] **文档完整性 8/10**
- [ ] **至少一个外部用户测试过**

### 推荐完成

- [ ] CSRF 防护 (T2.1)
- [ ] 路由缓存 (T3.1)
- [ ] 测试辅助 (T4.1)
- [ ] Telemetry (T4.3)

---

## 六、风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|---------|
| Handler 拆分破坏兼容性 | 高 | 完整测试 + deprecation 周期 |
| touch_page 逻辑变更导致数据丢失 | 高 | 渐进式迁移 + 数据迁移脚本 |
| CSRF 引入后与现有 HTMX 不兼容 | 中 | 默认关闭 + 详细文档 |
| 路由缓存导致热重载失效 | 中 | 重载时清除缓存 |

---

## 七、时间估算

| Phase | 任务数 | 估算时间 |
|-------|--------|---------|
| Phase 1: 基础设施 | 3 | 2-3 天 |
| Phase 2: 安全性 | 3 | 1-2 天 |
| Phase 3: 性能优化 | 2 | 1 天 |
| Phase 4: DX 提升 | 3 | 1-2 天 |
| Phase 5: 文档与发布 | 3 | 1 天 |
| **总计** | **14** | **6-9 天** |

---

## 八、下一步行动

1. **立即开始**: T1.1.1 (创建 Nex.Handler.Core)
2. **并行启动**: T1.2.1 (设计元数据结构)
3. **第一周完成**: Phase 1 全部
4. **第二周完成**: Phase 2-4
5. **第三周**: Phase 5 + 发布

---

**文档版本**: 1.0
**下次审查**: 2025年1月
